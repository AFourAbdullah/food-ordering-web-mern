import{aj as rr,Z as Yt,ag as dt,x as Ye,ak as Xo,y as Z,al as xs,am as Jo,an as Qo,ao as ei,ap as ti,aq as ni,ar as ri,as as si,at as oi,au as $r,n as Ut,I as fn,o as ee,av as Dr,O as sr,X as or,aw as Xt,ai as xn}from"./index-5beaefa8.js";import{w as Jt,S as ii,r as Es,e as _s,u as ai,f as ci,H as ks,g as Ve,h as ui,t as Bs,s as $n,B as ir,p as ar,i as li}from"./baseProvider.esm-5f95a1a7.js";import{n as di}from"./nacl-fast-5a57f8b4.js";const rn=BigInt(2**32-1),Dn=BigInt(32);function As(r,e=!1){return e?{h:Number(r&rn),l:Number(r>>Dn&rn)}:{h:Number(r>>Dn&rn)|0,l:Number(r&rn)|0}}function fi(r,e=!1){let t=new Uint32Array(r.length),n=new Uint32Array(r.length);for(let s=0;s<r.length;s++){const{h:o,l:i}=As(r[s],e);[t[s],n[s]]=[o,i]}return[t,n]}const hi=(r,e)=>BigInt(r>>>0)<<Dn|BigInt(e>>>0),pi=(r,e,t)=>r>>>t,gi=(r,e,t)=>r<<32-t|e>>>t,yi=(r,e,t)=>r>>>t|e<<32-t,mi=(r,e,t)=>r<<32-t|e>>>t,wi=(r,e,t)=>r<<64-t|e>>>t-32,bi=(r,e,t)=>r>>>t-32|e<<64-t,vi=(r,e)=>e,Si=(r,e)=>r,xi=(r,e,t)=>r<<t|e>>>32-t,Ei=(r,e,t)=>e<<t|r>>>32-t,_i=(r,e,t)=>e<<t-32|r>>>64-t,ki=(r,e,t)=>r<<t-32|e>>>64-t;function Bi(r,e,t,n){const s=(e>>>0)+(n>>>0);return{h:r+t+(s/2**32|0)|0,l:s|0}}const Ai=(r,e,t)=>(r>>>0)+(e>>>0)+(t>>>0),Ii=(r,e,t,n)=>e+t+n+(r/2**32|0)|0,Ri=(r,e,t,n)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0),Ci=(r,e,t,n,s)=>e+t+n+s+(r/2**32|0)|0,Ti=(r,e,t,n,s)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0)+(s>>>0),Oi=(r,e,t,n,s,o)=>e+t+n+s+o+(r/2**32|0)|0,$={fromBig:As,split:fi,toBig:hi,shrSH:pi,shrSL:gi,rotrSH:yi,rotrSL:mi,rotrBH:wi,rotrBL:bi,rotr32H:vi,rotr32L:Si,rotlSH:xi,rotlSL:Ei,rotlBH:_i,rotlBL:ki,add:Bi,add3L:Ai,add3H:Ii,add4L:Ri,add4H:Ci,add5H:Oi,add5L:Ti},[Pi,Li]=$.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),ot=new Uint32Array(80),it=new Uint32Array(80);class En extends ii{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:e,Al:t,Bh:n,Bl:s,Ch:o,Cl:i,Dh:a,Dl:c,Eh:u,El:l,Fh:y,Fl:_,Gh:p,Gl:g,Hh:d,Hl:f}=this;return[e,t,n,s,o,i,a,c,u,l,y,_,p,g,d,f]}set(e,t,n,s,o,i,a,c,u,l,y,_,p,g,d,f){this.Ah=e|0,this.Al=t|0,this.Bh=n|0,this.Bl=s|0,this.Ch=o|0,this.Cl=i|0,this.Dh=a|0,this.Dl=c|0,this.Eh=u|0,this.El=l|0,this.Fh=y|0,this.Fl=_|0,this.Gh=p|0,this.Gl=g|0,this.Hh=d|0,this.Hl=f|0}process(e,t){for(let h=0;h<16;h++,t+=4)ot[h]=e.getUint32(t),it[h]=e.getUint32(t+=4);for(let h=16;h<80;h++){const k=ot[h-15]|0,w=it[h-15]|0,E=$.rotrSH(k,w,1)^$.rotrSH(k,w,8)^$.shrSH(k,w,7),x=$.rotrSL(k,w,1)^$.rotrSL(k,w,8)^$.shrSL(k,w,7),A=ot[h-2]|0,W=it[h-2]|0,G=$.rotrSH(A,W,19)^$.rotrBH(A,W,61)^$.shrSH(A,W,6),j=$.rotrSL(A,W,19)^$.rotrBL(A,W,61)^$.shrSL(A,W,6),ae=$.add4L(x,j,it[h-7],it[h-16]),ce=$.add4H(ae,E,G,ot[h-7],ot[h-16]);ot[h]=ce|0,it[h]=ae|0}let{Ah:n,Al:s,Bh:o,Bl:i,Ch:a,Cl:c,Dh:u,Dl:l,Eh:y,El:_,Fh:p,Fl:g,Gh:d,Gl:f,Hh:m,Hl:v}=this;for(let h=0;h<80;h++){const k=$.rotrSH(y,_,14)^$.rotrSH(y,_,18)^$.rotrBH(y,_,41),w=$.rotrSL(y,_,14)^$.rotrSL(y,_,18)^$.rotrBL(y,_,41),E=y&p^~y&d,x=_&g^~_&f,A=$.add5L(v,w,x,Li[h],it[h]),W=$.add5H(A,m,k,E,Pi[h],ot[h]),G=A|0,j=$.rotrSH(n,s,28)^$.rotrBH(n,s,34)^$.rotrBH(n,s,39),ae=$.rotrSL(n,s,28)^$.rotrBL(n,s,34)^$.rotrBL(n,s,39),ce=n&o^n&a^o&a,Te=s&i^s&c^i&c;m=d|0,v=f|0,d=p|0,f=g|0,p=y|0,g=_|0,{h:y,l:_}=$.add(u|0,l|0,W|0,G|0),u=a|0,l=c|0,a=o|0,c=i|0,o=n|0,i=s|0;const C=$.add3L(G,ae,Te);n=$.add3H(C,W,j,ce),s=C|0}({h:n,l:s}=$.add(this.Ah|0,this.Al|0,n|0,s|0)),{h:o,l:i}=$.add(this.Bh|0,this.Bl|0,o|0,i|0),{h:a,l:c}=$.add(this.Ch|0,this.Cl|0,a|0,c|0),{h:u,l}=$.add(this.Dh|0,this.Dl|0,u|0,l|0),{h:y,l:_}=$.add(this.Eh|0,this.El|0,y|0,_|0),{h:p,l:g}=$.add(this.Fh|0,this.Fl|0,p|0,g|0),{h:d,l:f}=$.add(this.Gh|0,this.Gl|0,d|0,f|0),{h:m,l:v}=$.add(this.Hh|0,this.Hl|0,m|0,v|0),this.set(n,s,o,i,a,c,u,l,y,_,p,g,d,f,m,v)}roundClean(){ot.fill(0),it.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class Ni extends En{constructor(){super(),this.Ah=-1942145080,this.Al=424955298,this.Bh=1944164710,this.Bl=-1982016298,this.Ch=502970286,this.Cl=855612546,this.Dh=1738396948,this.Dl=1479516111,this.Eh=258812777,this.El=2077511080,this.Fh=2011393907,this.Fl=79989058,this.Gh=1067287976,this.Gl=1780299464,this.Hh=286451373,this.Hl=-1848208735,this.outputLen=28}}class Ui extends En{constructor(){super(),this.Ah=573645204,this.Al=-64227540,this.Bh=-1621794909,this.Bl=-934517566,this.Ch=596883563,this.Cl=1867755857,this.Dh=-1774684391,this.Dl=1497426621,this.Eh=-1775747358,this.El=-1467023389,this.Fh=-1101128155,this.Fl=1401305490,this.Gh=721525244,this.Gl=746961066,this.Hh=246885852,this.Hl=-2117784414,this.outputLen=32}}class qi extends En{constructor(){super(),this.Ah=-876896931,this.Al=-1056596264,this.Bh=1654270250,this.Bl=914150663,this.Ch=-1856437926,this.Cl=812702999,this.Dh=355462360,this.Dl=-150054599,this.Eh=1731405415,this.El=-4191439,this.Fh=-1900787065,this.Fl=1750603025,this.Gh=-619958771,this.Gl=1694076839,this.Hh=1203062813,this.Hl=-1090891868,this.outputLen=48}}const Is=Jt(()=>new En);Jt(()=>new Ni);Jt(()=>new Ui);Jt(()=>new qi);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Rs=BigInt(0),_n=BigInt(1),Fi=BigInt(2),kn=r=>r instanceof Uint8Array,zi=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function vt(r){if(!kn(r))throw new Error("Uint8Array expected");let e="";for(let t=0;t<r.length;t++)e+=zi[r[t]];return e}function Cs(r){const e=r.toString(16);return e.length&1?`0${e}`:e}function cr(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return BigInt(r===""?"0":`0x${r}`)}function Ot(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);const e=r.length;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const t=new Uint8Array(e/2);for(let n=0;n<t.length;n++){const s=n*2,o=r.slice(s,s+2),i=Number.parseInt(o,16);if(Number.isNaN(i)||i<0)throw new Error("Invalid byte sequence");t[n]=i}return t}function wt(r){return cr(vt(r))}function Rt(r){if(!kn(r))throw new Error("Uint8Array expected");return cr(vt(Uint8Array.from(r).reverse()))}function Ct(r,e){return Ot(r.toString(16).padStart(e*2,"0"))}function hn(r,e){return Ct(r,e).reverse()}function Ki(r){return Ot(Cs(r))}function ve(r,e,t){let n;if(typeof e=="string")try{n=Ot(e)}catch(o){throw new Error(`${r} must be valid hex string, got "${e}". Cause: ${o}`)}else if(kn(e))n=Uint8Array.from(e);else throw new Error(`${r} must be hex string or Uint8Array`);const s=n.length;if(typeof t=="number"&&s!==t)throw new Error(`${r} expected ${t} bytes, got ${s}`);return n}function St(...r){const e=new Uint8Array(r.reduce((n,s)=>n+s.length,0));let t=0;return r.forEach(n=>{if(!kn(n))throw new Error("Uint8Array expected");e.set(n,t),t+=n.length}),e}function Mi(r,e){if(r.length!==e.length)return!1;for(let t=0;t<r.length;t++)if(r[t]!==e[t])return!1;return!0}function Hi(r){if(typeof r!="string")throw new Error(`utf8ToBytes expected string, got ${typeof r}`);return new Uint8Array(new TextEncoder().encode(r))}function $i(r){let e;for(e=0;r>Rs;r>>=_n,e+=1);return e}function Di(r,e){return r>>BigInt(e)&_n}const ji=(r,e,t)=>r|(t?_n:Rs)<<BigInt(e),ur=r=>(Fi<<BigInt(r-1))-_n,Nn=r=>new Uint8Array(r),jr=r=>Uint8Array.from(r);function Ts(r,e,t){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let n=Nn(r),s=Nn(r),o=0;const i=()=>{n.fill(1),s.fill(0),o=0},a=(...y)=>t(s,n,...y),c=(y=Nn())=>{s=a(jr([0]),y),n=a(),y.length!==0&&(s=a(jr([1]),y),n=a())},u=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let y=0;const _=[];for(;y<e;){n=a();const p=n.slice();_.push(p),y+=n.length}return St(..._)};return(y,_)=>{i(),c(y);let p;for(;!(p=_(u()));)c();return i(),p}}const Wi={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,e)=>e.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function qt(r,e,t={}){const n=(s,o,i)=>{const a=Wi[o];if(typeof a!="function")throw new Error(`Invalid validator "${o}", expected function`);const c=r[s];if(!(i&&c===void 0)&&!a(c,r))throw new Error(`Invalid param ${String(s)}=${c} (${typeof c}), expected ${o}`)};for(const[s,o]of Object.entries(e))n(s,o,!1);for(const[s,o]of Object.entries(t))n(s,o,!0);return r}const Gi=Object.freeze(Object.defineProperty({__proto__:null,bitGet:Di,bitLen:$i,bitMask:ur,bitSet:ji,bytesToHex:vt,bytesToNumberBE:wt,bytesToNumberLE:Rt,concatBytes:St,createHmacDrbg:Ts,ensureBytes:ve,equalBytes:Mi,hexToBytes:Ot,hexToNumber:cr,numberToBytesBE:Ct,numberToBytesLE:hn,numberToHexUnpadded:Cs,numberToVarBytesBE:Ki,utf8ToBytes:Hi,validateObject:qt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const xe=BigInt(0),fe=BigInt(1),pt=BigInt(2),Vi=BigInt(3),jn=BigInt(4),Wr=BigInt(5),Gr=BigInt(8);BigInt(9);BigInt(16);function ue(r,e){const t=r%e;return t>=xe?t:e+t}function Zi(r,e,t){if(t<=xe||e<xe)throw new Error("Expected power/modulo > 0");if(t===fe)return xe;let n=fe;for(;e>xe;)e&fe&&(n=n*r%t),r=r*r%t,e>>=fe;return n}function pe(r,e,t){let n=r;for(;e-- >xe;)n*=n,n%=t;return n}function Wn(r,e){if(r===xe||e<=xe)throw new Error(`invert: expected positive integers, got n=${r} mod=${e}`);let t=ue(r,e),n=e,s=xe,o=fe;for(;t!==xe;){const a=n/t,c=n%t,u=s-o*a;n=t,t=c,s=o,o=u}if(n!==fe)throw new Error("invert: does not exist");return ue(s,e)}function Yi(r){const e=(r-fe)/pt;let t,n,s;for(t=r-fe,n=0;t%pt===xe;t/=pt,n++);for(s=pt;s<r&&Zi(s,e,r)!==r-fe;s++);if(n===1){const i=(r+fe)/jn;return function(c,u){const l=c.pow(u,i);if(!c.eql(c.sqr(l),u))throw new Error("Cannot find square root");return l}}const o=(t+fe)/pt;return function(a,c){if(a.pow(c,e)===a.neg(a.ONE))throw new Error("Cannot find square root");let u=n,l=a.pow(a.mul(a.ONE,s),t),y=a.pow(c,o),_=a.pow(c,t);for(;!a.eql(_,a.ONE);){if(a.eql(_,a.ZERO))return a.ZERO;let p=1;for(let d=a.sqr(_);p<u&&!a.eql(d,a.ONE);p++)d=a.sqr(d);const g=a.pow(l,fe<<BigInt(u-p-1));l=a.sqr(g),y=a.mul(y,g),_=a.mul(_,l),u=p}return y}}function Xi(r){if(r%jn===Vi){const e=(r+fe)/jn;return function(n,s){const o=n.pow(s,e);if(!n.eql(n.sqr(o),s))throw new Error("Cannot find square root");return o}}if(r%Gr===Wr){const e=(r-Wr)/Gr;return function(n,s){const o=n.mul(s,pt),i=n.pow(o,e),a=n.mul(s,i),c=n.mul(n.mul(a,pt),i),u=n.mul(a,n.sub(c,n.ONE));if(!n.eql(n.sqr(u),s))throw new Error("Cannot find square root");return u}}return Yi(r)}const Ji=(r,e)=>(ue(r,e)&fe)===fe,Qi=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ea(r){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=Qi.reduce((n,s)=>(n[s]="function",n),e);return qt(r,t)}function ta(r,e,t){if(t<xe)throw new Error("Expected power > 0");if(t===xe)return r.ONE;if(t===fe)return e;let n=r.ONE,s=e;for(;t>xe;)t&fe&&(n=r.mul(n,s)),s=r.sqr(s),t>>=fe;return n}function na(r,e){const t=new Array(e.length),n=e.reduce((o,i,a)=>r.is0(i)?o:(t[a]=o,r.mul(o,i)),r.ONE),s=r.inv(n);return e.reduceRight((o,i,a)=>r.is0(i)?o:(t[a]=r.mul(o,t[a]),r.mul(o,i)),s),t}function lr(r,e){const t=e!==void 0?e:r.toString(2).length,n=Math.ceil(t/8);return{nBitLength:t,nByteLength:n}}function Os(r,e,t=!1,n={}){if(r<=xe)throw new Error(`Expected Fp ORDER > 0, got ${r}`);const{nBitLength:s,nByteLength:o}=lr(r,e);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const i=Xi(r),a=Object.freeze({ORDER:r,BITS:s,BYTES:o,MASK:ur(s),ZERO:xe,ONE:fe,create:c=>ue(c,r),isValid:c=>{if(typeof c!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);return xe<=c&&c<r},is0:c=>c===xe,isOdd:c=>(c&fe)===fe,neg:c=>ue(-c,r),eql:(c,u)=>c===u,sqr:c=>ue(c*c,r),add:(c,u)=>ue(c+u,r),sub:(c,u)=>ue(c-u,r),mul:(c,u)=>ue(c*u,r),pow:(c,u)=>ta(a,c,u),div:(c,u)=>ue(c*Wn(u,r),r),sqrN:c=>c*c,addN:(c,u)=>c+u,subN:(c,u)=>c-u,mulN:(c,u)=>c*u,inv:c=>Wn(c,r),sqrt:n.sqrt||(c=>i(a,c)),invertBatch:c=>na(a,c),cmov:(c,u,l)=>l?u:c,toBytes:c=>t?hn(c,o):Ct(c,o),fromBytes:c=>{if(c.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${c.length}`);return t?Rt(c):wt(c)}});return Object.freeze(a)}function ra(r,e){if(!r.isOdd)throw new Error("Field doesn't have isOdd");const t=r.sqrt(e);return r.isOdd(t)?r.neg(t):t}function sa(r,e,t=!1){r=ve("privateHash",r);const n=r.length,s=lr(e).nByteLength+8;if(s<24||n<s||n>1024)throw new Error(`hashToPrivateScalar: expected ${s}-1024 bytes of input, got ${n}`);const o=t?Rt(r):wt(r);return ue(o,e-fe)+fe}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const oa=BigInt(0),Un=BigInt(1);function Ps(r,e){const t=(s,o)=>{const i=o.negate();return s?i:o},n=s=>{const o=Math.ceil(e/s)+1,i=2**(s-1);return{windows:o,windowSize:i}};return{constTimeNegate:t,unsafeLadder(s,o){let i=r.ZERO,a=s;for(;o>oa;)o&Un&&(i=i.add(a)),a=a.double(),o>>=Un;return i},precomputeWindow(s,o){const{windows:i,windowSize:a}=n(o),c=[];let u=s,l=u;for(let y=0;y<i;y++){l=u,c.push(l);for(let _=1;_<a;_++)l=l.add(u),c.push(l);u=l.double()}return c},wNAF(s,o,i){const{windows:a,windowSize:c}=n(s);let u=r.ZERO,l=r.BASE;const y=BigInt(2**s-1),_=2**s,p=BigInt(s);for(let g=0;g<a;g++){const d=g*c;let f=Number(i&y);i>>=p,f>c&&(f-=_,i+=Un);const m=d,v=d+Math.abs(f)-1,h=g%2!==0,k=f<0;f===0?l=l.add(t(h,o[m])):u=u.add(t(k,o[v]))}return{p:u,f:l}},wNAFCached(s,o,i,a){const c=s._WINDOW_SIZE||1;let u=o.get(s);return u||(u=this.precomputeWindow(s,c),c!==1&&o.set(s,a(u))),this.wNAF(c,u,i)}}}function dr(r){return ea(r.Fp),qt(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...lr(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const $e=BigInt(0),Le=BigInt(1),sn=BigInt(2),ia=BigInt(8),aa={zip215:!0};function ca(r){const e=dr(r);return qt(r,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}function fr(r){const e=ca(r),{Fp:t,n,prehash:s,hash:o,randomBytes:i,nByteLength:a,h:c}=e,u=sn<<BigInt(a*8)-Le,l=t.create,y=e.uvRatio||((O,B)=>{try{return{isValid:!0,value:t.sqrt(O*t.inv(B))}}catch{return{isValid:!1,value:$e}}}),_=e.adjustScalarBytes||(O=>O),p=e.domain||((O,B,N)=>{if(B.length||N)throw new Error("Contexts/pre-hash are not supported");return O}),g=O=>typeof O=="bigint"&&$e<O,d=(O,B)=>g(O)&&g(B)&&O<B,f=O=>O===$e||d(O,u);function m(O,B){if(d(O,B))return O;throw new Error(`Expected valid scalar < ${B}, got ${typeof O} ${O}`)}function v(O){return O===$e?O:m(O,n)}const h=new Map;function k(O){if(!(O instanceof w))throw new Error("ExtendedPoint expected")}class w{constructor(B,N,z,D){if(this.ex=B,this.ey=N,this.ez=z,this.et=D,!f(B))throw new Error("x required");if(!f(N))throw new Error("y required");if(!f(z))throw new Error("z required");if(!f(D))throw new Error("t required")}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(B){if(B instanceof w)throw new Error("extended point not allowed");const{x:N,y:z}=B||{};if(!f(N)||!f(z))throw new Error("invalid affine point");return new w(N,z,Le,l(N*z))}static normalizeZ(B){const N=t.invertBatch(B.map(z=>z.ez));return B.map((z,D)=>z.toAffine(N[D])).map(w.fromAffine)}_setWindowSize(B){this._WINDOW_SIZE=B,h.delete(this)}assertValidity(){const{a:B,d:N}=e;if(this.is0())throw new Error("bad point: ZERO");const{ex:z,ey:D,ez:X,et:Q}=this,oe=l(z*z),te=l(D*D),ne=l(X*X),we=l(ne*ne),he=l(oe*B),Ee=l(ne*l(he+te)),_e=l(we+l(N*l(oe*te)));if(Ee!==_e)throw new Error("bad point: equation left != right (1)");const Ie=l(z*D),ye=l(X*Q);if(Ie!==ye)throw new Error("bad point: equation left != right (2)")}equals(B){k(B);const{ex:N,ey:z,ez:D}=this,{ex:X,ey:Q,ez:oe}=B,te=l(N*oe),ne=l(X*D),we=l(z*oe),he=l(Q*D);return te===ne&&we===he}is0(){return this.equals(w.ZERO)}negate(){return new w(l(-this.ex),this.ey,this.ez,l(-this.et))}double(){const{a:B}=e,{ex:N,ey:z,ez:D}=this,X=l(N*N),Q=l(z*z),oe=l(sn*l(D*D)),te=l(B*X),ne=N+z,we=l(l(ne*ne)-X-Q),he=te+Q,Ee=he-oe,_e=te-Q,Ie=l(we*Ee),ye=l(he*_e),He=l(we*_e),ht=l(Ee*he);return new w(Ie,ye,ht,He)}add(B){k(B);const{a:N,d:z}=e,{ex:D,ey:X,ez:Q,et:oe}=this,{ex:te,ey:ne,ez:we,et:he}=B;if(N===BigInt(-1)){const Ur=l((X-D)*(ne+te)),qr=l((X+D)*(ne-te)),Ln=l(qr-Ur);if(Ln===$e)return this.double();const Fr=l(Q*sn*he),zr=l(oe*sn*we),Kr=zr+Fr,Mr=qr+Ur,Hr=zr-Fr,Go=l(Kr*Ln),Vo=l(Mr*Hr),Zo=l(Kr*Hr),Yo=l(Ln*Mr);return new w(Go,Vo,Yo,Zo)}const Ee=l(D*te),_e=l(X*ne),Ie=l(oe*z*he),ye=l(Q*we),He=l((D+X)*(te+ne)-Ee-_e),ht=ye-Ie,Ht=ye+Ie,Nr=l(_e-N*Ee),$o=l(He*ht),Do=l(Ht*Nr),jo=l(He*Nr),Wo=l(ht*Ht);return new w($o,Do,Wo,jo)}subtract(B){return this.add(B.negate())}wNAF(B){return A.wNAFCached(this,h,B,w.normalizeZ)}multiply(B){const{p:N,f:z}=this.wNAF(m(B,n));return w.normalizeZ([N,z])[0]}multiplyUnsafe(B){let N=v(B);return N===$e?x:this.equals(x)||N===Le?this:this.equals(E)?this.wNAF(N).p:A.unsafeLadder(this,N)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return A.unsafeLadder(this,n).is0()}toAffine(B){const{ex:N,ey:z,ez:D}=this,X=this.is0();B==null&&(B=X?ia:t.inv(D));const Q=l(N*B),oe=l(z*B),te=l(D*B);if(X)return{x:$e,y:Le};if(te!==Le)throw new Error("invZ was invalid");return{x:Q,y:oe}}clearCofactor(){const{h:B}=e;return B===Le?this:this.multiplyUnsafe(B)}static fromHex(B,N=!1){const{d:z,a:D}=e,X=t.BYTES;B=ve("pointHex",B,X);const Q=B.slice(),oe=B[X-1];Q[X-1]=oe&-129;const te=Rt(Q);te===$e||(N?m(te,u):m(te,t.ORDER));const ne=l(te*te),we=l(ne-Le),he=l(z*ne-D);let{isValid:Ee,value:_e}=y(we,he);if(!Ee)throw new Error("Point.fromHex: invalid y coordinate");const Ie=(_e&Le)===Le,ye=(oe&128)!==0;if(!N&&_e===$e&&ye)throw new Error("Point.fromHex: x=0 and x_0=1");return ye!==Ie&&(_e=l(-_e)),w.fromAffine({x:_e,y:te})}static fromPrivateKey(B){return j(B).point}toRawBytes(){const{x:B,y:N}=this.toAffine(),z=hn(N,t.BYTES);return z[z.length-1]|=B&Le?128:0,z}toHex(){return vt(this.toRawBytes())}}w.BASE=new w(e.Gx,e.Gy,Le,l(e.Gx*e.Gy)),w.ZERO=new w($e,Le,Le,$e);const{BASE:E,ZERO:x}=w,A=Ps(w,a*8);function W(O){return ue(O,n)}function G(O){return W(Rt(O))}function j(O){const B=a;O=ve("private key",O,B);const N=ve("hashed private key",o(O),2*B),z=_(N.slice(0,B)),D=N.slice(B,2*B),X=G(z),Q=E.multiply(X),oe=Q.toRawBytes();return{head:z,prefix:D,scalar:X,point:Q,pointBytes:oe}}function ae(O){return j(O).pointBytes}function ce(O=new Uint8Array,...B){const N=St(...B);return G(o(p(N,ve("context",O),!!s)))}function Te(O,B,N={}){O=ve("message",O),s&&(O=s(O));const{prefix:z,scalar:D,pointBytes:X}=j(B),Q=ce(N.context,z,O),oe=E.multiply(Q).toRawBytes(),te=ce(N.context,oe,X,O),ne=W(Q+te*D);v(ne);const we=St(oe,hn(ne,t.BYTES));return ve("result",we,a*2)}const C=aa;function U(O,B,N,z=C){const{context:D,zip215:X}=z,Q=t.BYTES;O=ve("signature",O,2*Q),B=ve("message",B),s&&(B=s(B));const oe=Rt(O.slice(Q,2*Q));let te,ne,we;try{te=w.fromHex(N,X),ne=w.fromHex(O.slice(0,Q),X),we=E.multiplyUnsafe(oe)}catch{return!1}if(!X&&te.isSmallOrder())return!1;const he=ce(D,ne.toRawBytes(),te.toRawBytes(),B);return ne.add(te.multiplyUnsafe(he)).subtract(we).clearCofactor().equals(w.ZERO)}return E._setWindowSize(8),{CURVE:e,getPublicKey:ae,sign:Te,verify:U,ExtendedPoint:w,utils:{getExtendedPublicKey:j,randomPrivateKey:()=>i(t.BYTES),precompute(O=8,B=w.BASE){return B._setWindowSize(O),B.multiply(BigInt(3)),B}}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */BigInt(0);BigInt(1);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const hr=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),Vr=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt(0);const ua=BigInt(1),Gn=BigInt(2),la=BigInt(5),Zr=BigInt(10),da=BigInt(20),fa=BigInt(40),Yr=BigInt(80);function ha(r){const e=hr,n=r*r%e*r%e,s=pe(n,Gn,e)*n%e,o=pe(s,ua,e)*r%e,i=pe(o,la,e)*o%e,a=pe(i,Zr,e)*i%e,c=pe(a,da,e)*a%e,u=pe(c,fa,e)*c%e,l=pe(u,Yr,e)*u%e,y=pe(l,Yr,e)*u%e,_=pe(y,Zr,e)*i%e;return{pow_p_5_8:pe(_,Gn,e)*r%e,b2:n}}function pa(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}function ga(r,e){const t=hr,n=ue(e*e*e,t),s=ue(n*n*e,t),o=ha(r*s).pow_p_5_8;let i=ue(r*n*o,t);const a=ue(e*i*i,t),c=i,u=ue(i*Vr,t),l=a===r,y=a===ue(-r,t),_=a===ue(-r*Vr,t);return l&&(i=c),(y||_)&&(i=u),Ji(i,t)&&(i=ue(-i,t)),{isValid:l||y,value:i}}const rt=Os(hr,void 0,!0),pr={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:rt,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:BigInt(8),Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:Is,randomBytes:Es,adjustScalarBytes:pa,uvRatio:ga},Ft=fr(pr);function Ls(r,e,t){if(e.length>255)throw new Error("Context is too big");return _s(ai("SigEd25519 no Ed25519 collisions"),new Uint8Array([t?1:0,e.length]),e,r)}fr({...pr,domain:Ls});fr({...pr,domain:Ls,prehash:Is});const ya=(rt.ORDER+BigInt(3))/BigInt(8);rt.pow(Gn,ya);rt.sqrt(rt.neg(rt.ONE));(rt.ORDER-BigInt(5))/BigInt(8);BigInt(486662);ra(rt,rt.neg(BigInt(486664)));BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");var on=rr.Buffer;function ma(r){if(r.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),t=0;t<e.length;t++)e[t]=255;for(var n=0;n<r.length;n++){var s=r.charAt(n),o=s.charCodeAt(0);if(e[o]!==255)throw new TypeError(s+" is ambiguous");e[o]=n}var i=r.length,a=r.charAt(0),c=Math.log(i)/Math.log(256),u=Math.log(256)/Math.log(i);function l(p){if((Array.isArray(p)||p instanceof Uint8Array)&&(p=on.from(p)),!on.isBuffer(p))throw new TypeError("Expected Buffer");if(p.length===0)return"";for(var g=0,d=0,f=0,m=p.length;f!==m&&p[f]===0;)f++,g++;for(var v=(m-f)*u+1>>>0,h=new Uint8Array(v);f!==m;){for(var k=p[f],w=0,E=v-1;(k!==0||w<d)&&E!==-1;E--,w++)k+=256*h[E]>>>0,h[E]=k%i>>>0,k=k/i>>>0;if(k!==0)throw new Error("Non-zero carry");d=w,f++}for(var x=v-d;x!==v&&h[x]===0;)x++;for(var A=a.repeat(g);x<v;++x)A+=r.charAt(h[x]);return A}function y(p){if(typeof p!="string")throw new TypeError("Expected String");if(p.length===0)return on.alloc(0);for(var g=0,d=0,f=0;p[g]===a;)d++,g++;for(var m=(p.length-g)*c+1>>>0,v=new Uint8Array(m);p[g];){var h=e[p.charCodeAt(g)];if(h===255)return;for(var k=0,w=m-1;(h!==0||k<f)&&w!==-1;w--,k++)h+=i*v[w]>>>0,v[w]=h%256>>>0,h=h/256>>>0;if(h!==0)throw new Error("Non-zero carry");f=k,g++}for(var E=m-f;E!==m&&v[E]===0;)E++;var x=on.allocUnsafe(d+(m-E));x.fill(0,0,d);for(var A=d;E!==m;)x[A++]=v[E++];return x}function _(p){var g=y(p);if(g)return g;throw new Error("Non-base"+i+" character")}return{encode:l,decodeUnsafe:y,decode:_}}var wa=ma,ba=wa,va="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",Sa=ba(va);const Ae=Yt(Sa);var Be={},an=rr.Buffer;function xa(r){if(r.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),t=0;t<e.length;t++)e[t]=255;for(var n=0;n<r.length;n++){var s=r.charAt(n),o=s.charCodeAt(0);if(e[o]!==255)throw new TypeError(s+" is ambiguous");e[o]=n}var i=r.length,a=r.charAt(0),c=Math.log(i)/Math.log(256),u=Math.log(256)/Math.log(i);function l(p){if((Array.isArray(p)||p instanceof Uint8Array)&&(p=an.from(p)),!an.isBuffer(p))throw new TypeError("Expected Buffer");if(p.length===0)return"";for(var g=0,d=0,f=0,m=p.length;f!==m&&p[f]===0;)f++,g++;for(var v=(m-f)*u+1>>>0,h=new Uint8Array(v);f!==m;){for(var k=p[f],w=0,E=v-1;(k!==0||w<d)&&E!==-1;E--,w++)k+=256*h[E]>>>0,h[E]=k%i>>>0,k=k/i>>>0;if(k!==0)throw new Error("Non-zero carry");d=w,f++}for(var x=v-d;x!==v&&h[x]===0;)x++;for(var A=a.repeat(g);x<v;++x)A+=r.charAt(h[x]);return A}function y(p){if(typeof p!="string")throw new TypeError("Expected String");if(p.length===0)return an.alloc(0);for(var g=0,d=0,f=0;p[g]===a;)d++,g++;for(var m=(p.length-g)*c+1>>>0,v=new Uint8Array(m);p[g];){var h=e[p.charCodeAt(g)];if(h===255)return;for(var k=0,w=m-1;(h!==0||k<f)&&w!==-1;w--,k++)h+=i*v[w]>>>0,v[w]=h%256>>>0,h=h/256>>>0;if(h!==0)throw new Error("Non-zero carry");f=k,g++}for(var E=m-f;E!==m&&v[E]===0;)E++;var x=an.allocUnsafe(d+(m-E));x.fill(0,0,d);for(var A=d;E!==m;)x[A++]=v[E++];return x}function _(p){var g=y(p);if(g)return g;throw new Error("Non-base"+i+" character")}return{encode:l,decodeUnsafe:y,decode:_}}var Ea=xa,_a=Ea,ka="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",Ba=_a(ka);function tt(r,e,t){return e<=r&&r<=t}function Bn(r){if(r===void 0)return{};if(r===Object(r))return r;throw TypeError("Could not convert argument to dictionary")}function Aa(r){for(var e=String(r),t=e.length,n=0,s=[];n<t;){var o=e.charCodeAt(n);if(o<55296||o>57343)s.push(o);else if(56320<=o&&o<=57343)s.push(65533);else if(55296<=o&&o<=56319)if(n===t-1)s.push(65533);else{var i=r.charCodeAt(n+1);if(56320<=i&&i<=57343){var a=o&1023,c=i&1023;s.push(65536+(a<<10)+c),n+=1}else s.push(65533)}n+=1}return s}function Ia(r){for(var e="",t=0;t<r.length;++t){var n=r[t];n<=65535?e+=String.fromCharCode(n):(n-=65536,e+=String.fromCharCode((n>>10)+55296,(n&1023)+56320))}return e}var pn=-1;function gr(r){this.tokens=[].slice.call(r)}gr.prototype={endOfStream:function(){return!this.tokens.length},read:function(){return this.tokens.length?this.tokens.shift():pn},prepend:function(r){if(Array.isArray(r))for(var e=r;e.length;)this.tokens.unshift(e.pop());else this.tokens.unshift(r)},push:function(r){if(Array.isArray(r))for(var e=r;e.length;)this.tokens.push(e.shift());else this.tokens.push(r)}};var Pt=-1;function qn(r,e){if(r)throw TypeError("Decoder error");return e||65533}var gn="utf-8";function yn(r,e){if(!(this instanceof yn))return new yn(r,e);if(r=r!==void 0?String(r).toLowerCase():gn,r!==gn)throw new Error("Encoding not supported. Only utf-8 is supported");e=Bn(e),this._streaming=!1,this._BOMseen=!1,this._decoder=null,this._fatal=!!e.fatal,this._ignoreBOM=!!e.ignoreBOM,Object.defineProperty(this,"encoding",{value:"utf-8"}),Object.defineProperty(this,"fatal",{value:this._fatal}),Object.defineProperty(this,"ignoreBOM",{value:this._ignoreBOM})}yn.prototype={decode:function(e,t){var n;typeof e=="object"&&e instanceof ArrayBuffer?n=new Uint8Array(e):typeof e=="object"&&"buffer"in e&&e.buffer instanceof ArrayBuffer?n=new Uint8Array(e.buffer,e.byteOffset,e.byteLength):n=new Uint8Array(0),t=Bn(t),this._streaming||(this._decoder=new Ra({fatal:this._fatal}),this._BOMseen=!1),this._streaming=!!t.stream;for(var s=new gr(n),o=[],i;!s.endOfStream()&&(i=this._decoder.handler(s,s.read()),i!==Pt);)i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i));if(!this._streaming){do{if(i=this._decoder.handler(s,s.read()),i===Pt)break;i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i))}while(!s.endOfStream());this._decoder=null}return o.length&&["utf-8"].indexOf(this.encoding)!==-1&&!this._ignoreBOM&&!this._BOMseen&&(o[0]===65279?(this._BOMseen=!0,o.shift()):this._BOMseen=!0),Ia(o)}};function mn(r,e){if(!(this instanceof mn))return new mn(r,e);if(r=r!==void 0?String(r).toLowerCase():gn,r!==gn)throw new Error("Encoding not supported. Only utf-8 is supported");e=Bn(e),this._streaming=!1,this._encoder=null,this._options={fatal:!!e.fatal},Object.defineProperty(this,"encoding",{value:"utf-8"})}mn.prototype={encode:function(e,t){e=e?String(e):"",t=Bn(t),this._streaming||(this._encoder=new Ca(this._options)),this._streaming=!!t.stream;for(var n=[],s=new gr(Aa(e)),o;!s.endOfStream()&&(o=this._encoder.handler(s,s.read()),o!==Pt);)Array.isArray(o)?n.push.apply(n,o):n.push(o);if(!this._streaming){for(;o=this._encoder.handler(s,s.read()),o!==Pt;)Array.isArray(o)?n.push.apply(n,o):n.push(o);this._encoder=null}return new Uint8Array(n)}};function Ra(r){var e=r.fatal,t=0,n=0,s=0,o=128,i=191;this.handler=function(a,c){if(c===pn&&s!==0)return s=0,qn(e);if(c===pn)return Pt;if(s===0){if(tt(c,0,127))return c;if(tt(c,194,223))s=1,t=c-192;else if(tt(c,224,239))c===224&&(o=160),c===237&&(i=159),s=2,t=c-224;else if(tt(c,240,244))c===240&&(o=144),c===244&&(i=143),s=3,t=c-240;else return qn(e);return t=t<<6*s,null}if(!tt(c,o,i))return t=s=n=0,o=128,i=191,a.prepend(c),qn(e);if(o=128,i=191,n+=1,t+=c-128<<6*(s-n),n!==s)return null;var u=t;return t=s=n=0,u}}function Ca(r){r.fatal,this.handler=function(e,t){if(t===pn)return Pt;if(tt(t,0,127))return t;var n,s;tt(t,128,2047)?(n=1,s=192):tt(t,2048,65535)?(n=2,s=224):tt(t,65536,1114111)&&(n=3,s=240);for(var o=[(t>>6*n)+s];n>0;){var i=t>>6*(n-1);o.push(128|i&63),n-=1}return o}}const Ta=Object.freeze(Object.defineProperty({__proto__:null,TextDecoder:yn,TextEncoder:mn},Symbol.toStringTag,{value:"Module"})),Oa=dt(Ta);var Pa=Ye&&Ye.__createBinding||(Object.create?function(r,e,t,n){n===void 0&&(n=t),Object.defineProperty(r,n,{enumerable:!0,get:function(){return e[t]}})}:function(r,e,t,n){n===void 0&&(n=t),r[n]=e[t]}),La=Ye&&Ye.__setModuleDefault||(Object.create?function(r,e){Object.defineProperty(r,"default",{enumerable:!0,value:e})}:function(r,e){r.default=e}),Xe=Ye&&Ye.__decorate||function(r,e,t,n){var s=arguments.length,o=s<3?e:n===null?n=Object.getOwnPropertyDescriptor(e,t):n,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(r,e,t,n);else for(var a=r.length-1;a>=0;a--)(i=r[a])&&(o=(s<3?i(o):s>3?i(e,t,o):i(e,t))||o);return s>3&&o&&Object.defineProperty(e,t,o),o},Na=Ye&&Ye.__importStar||function(r){if(r&&r.__esModule)return r;var e={};if(r!=null)for(var t in r)t!=="default"&&Object.hasOwnProperty.call(r,t)&&Pa(e,r,t);return La(e,r),e},Ns=Ye&&Ye.__importDefault||function(r){return r&&r.__esModule?r:{default:r}};Object.defineProperty(Be,"__esModule",{value:!0});var Us=Be.deserializeUnchecked=Hs=Be.deserialize=Ms=Be.serialize=Be.BinaryReader=Be.BinaryWriter=Be.BorshError=Be.baseDecode=Be.baseEncode=void 0;const ct=Ns(Xo),qs=Ns(Ba),Ua=Na(Oa),qa=typeof TextDecoder!="function"?Ua.TextDecoder:TextDecoder,Fa=new qa("utf-8",{fatal:!0});function za(r){return typeof r=="string"&&(r=Buffer.from(r,"utf8")),qs.default.encode(Buffer.from(r))}Be.baseEncode=za;function Ka(r){return Buffer.from(qs.default.decode(r))}Be.baseDecode=Ka;const Fn=1024;class Re extends Error{constructor(e){super(e),this.fieldPath=[],this.originalMessage=e}addToFieldPath(e){this.fieldPath.splice(0,0,e),this.message=this.originalMessage+": "+this.fieldPath.join(".")}}Be.BorshError=Re;class Fs{constructor(){this.buf=Buffer.alloc(Fn),this.length=0}maybeResize(){this.buf.length<16+this.length&&(this.buf=Buffer.concat([this.buf,Buffer.alloc(Fn)]))}writeU8(e){this.maybeResize(),this.buf.writeUInt8(e,this.length),this.length+=1}writeU16(e){this.maybeResize(),this.buf.writeUInt16LE(e,this.length),this.length+=2}writeU32(e){this.maybeResize(),this.buf.writeUInt32LE(e,this.length),this.length+=4}writeU64(e){this.maybeResize(),this.writeBuffer(Buffer.from(new ct.default(e).toArray("le",8)))}writeU128(e){this.maybeResize(),this.writeBuffer(Buffer.from(new ct.default(e).toArray("le",16)))}writeU256(e){this.maybeResize(),this.writeBuffer(Buffer.from(new ct.default(e).toArray("le",32)))}writeU512(e){this.maybeResize(),this.writeBuffer(Buffer.from(new ct.default(e).toArray("le",64)))}writeBuffer(e){this.buf=Buffer.concat([Buffer.from(this.buf.subarray(0,this.length)),e,Buffer.alloc(Fn)]),this.length+=e.length}writeString(e){this.maybeResize();const t=Buffer.from(e,"utf8");this.writeU32(t.length),this.writeBuffer(t)}writeFixedArray(e){this.writeBuffer(Buffer.from(e))}writeArray(e,t){this.maybeResize(),this.writeU32(e.length);for(const n of e)this.maybeResize(),t(n)}toArray(){return this.buf.subarray(0,this.length)}}Be.BinaryWriter=Fs;function Je(r,e,t){const n=t.value;t.value=function(...s){try{return n.apply(this,s)}catch(o){if(o instanceof RangeError){const i=o.code;if(["ERR_BUFFER_OUT_OF_BOUNDS","ERR_OUT_OF_RANGE"].indexOf(i)>=0)throw new Re("Reached the end of buffer when deserializing")}throw o}}}class Ue{constructor(e){this.buf=e,this.offset=0}readU8(){const e=this.buf.readUInt8(this.offset);return this.offset+=1,e}readU16(){const e=this.buf.readUInt16LE(this.offset);return this.offset+=2,e}readU32(){const e=this.buf.readUInt32LE(this.offset);return this.offset+=4,e}readU64(){const e=this.readBuffer(8);return new ct.default(e,"le")}readU128(){const e=this.readBuffer(16);return new ct.default(e,"le")}readU256(){const e=this.readBuffer(32);return new ct.default(e,"le")}readU512(){const e=this.readBuffer(64);return new ct.default(e,"le")}readBuffer(e){if(this.offset+e>this.buf.length)throw new Re(`Expected buffer length ${e} isn't within bounds`);const t=this.buf.slice(this.offset,this.offset+e);return this.offset+=e,t}readString(){const e=this.readU32(),t=this.readBuffer(e);try{return Fa.decode(t)}catch(n){throw new Re(`Error decoding UTF-8 string: ${n}`)}}readFixedArray(e){return new Uint8Array(this.readBuffer(e))}readArray(e){const t=this.readU32(),n=Array();for(let s=0;s<t;++s)n.push(e());return n}}Xe([Je],Ue.prototype,"readU8",null);Xe([Je],Ue.prototype,"readU16",null);Xe([Je],Ue.prototype,"readU32",null);Xe([Je],Ue.prototype,"readU64",null);Xe([Je],Ue.prototype,"readU128",null);Xe([Je],Ue.prototype,"readU256",null);Xe([Je],Ue.prototype,"readU512",null);Xe([Je],Ue.prototype,"readString",null);Xe([Je],Ue.prototype,"readFixedArray",null);Xe([Je],Ue.prototype,"readArray",null);Be.BinaryReader=Ue;function zs(r){return r.charAt(0).toUpperCase()+r.slice(1)}function gt(r,e,t,n,s){try{if(typeof n=="string")s[`write${zs(n)}`](t);else if(n instanceof Array)if(typeof n[0]=="number"){if(t.length!==n[0])throw new Re(`Expecting byte array of length ${n[0]}, but got ${t.length} bytes`);s.writeFixedArray(t)}else if(n.length===2&&typeof n[1]=="number"){if(t.length!==n[1])throw new Re(`Expecting byte array of length ${n[1]}, but got ${t.length} bytes`);for(let o=0;o<n[1];o++)gt(r,null,t[o],n[0],s)}else s.writeArray(t,o=>{gt(r,e,o,n[0],s)});else if(n.kind!==void 0)switch(n.kind){case"option":{t==null?s.writeU8(0):(s.writeU8(1),gt(r,e,t,n.type,s));break}case"map":{s.writeU32(t.size),t.forEach((o,i)=>{gt(r,e,i,n.key,s),gt(r,e,o,n.value,s)});break}default:throw new Re(`FieldType ${n} unrecognized`)}else Ks(r,t,s)}catch(o){throw o instanceof Re&&o.addToFieldPath(e),o}}function Ks(r,e,t){if(typeof e.borshSerialize=="function"){e.borshSerialize(t);return}const n=r.get(e.constructor);if(!n)throw new Re(`Class ${e.constructor.name} is missing in schema`);if(n.kind==="struct")n.fields.map(([s,o])=>{gt(r,s,e[s],o,t)});else if(n.kind==="enum"){const s=e[n.field];for(let o=0;o<n.values.length;++o){const[i,a]=n.values[o];if(i===s){t.writeU8(o),gt(r,i,e[i],a,t);break}}}else throw new Re(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function Ma(r,e,t=Fs){const n=new t;return Ks(r,e,n),n.toArray()}var Ms=Be.serialize=Ma;function yt(r,e,t,n){try{if(typeof t=="string")return n[`read${zs(t)}`]();if(t instanceof Array){if(typeof t[0]=="number")return n.readFixedArray(t[0]);if(typeof t[1]=="number"){const s=[];for(let o=0;o<t[1];o++)s.push(yt(r,null,t[0],n));return s}else return n.readArray(()=>yt(r,e,t[0],n))}if(t.kind==="option")return n.readU8()?yt(r,e,t.type,n):void 0;if(t.kind==="map"){let s=new Map;const o=n.readU32();for(let i=0;i<o;i++){const a=yt(r,e,t.key,n),c=yt(r,e,t.value,n);s.set(a,c)}return s}return yr(r,t,n)}catch(s){throw s instanceof Re&&s.addToFieldPath(e),s}}function yr(r,e,t){if(typeof e.borshDeserialize=="function")return e.borshDeserialize(t);const n=r.get(e);if(!n)throw new Re(`Class ${e.name} is missing in schema`);if(n.kind==="struct"){const s={};for(const[o,i]of r.get(e).fields)s[o]=yt(r,o,i,t);return new e(s)}if(n.kind==="enum"){const s=t.readU8();if(s>=n.values.length)throw new Re(`Enum index: ${s} is out of range`);const[o,i]=n.values[s],a=yt(r,o,i,t);return new e({[o]:a})}throw new Re(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function Ha(r,e,t,n=Ue){const s=new n(t),o=yr(r,e,s);if(s.offset<t.length)throw new Re(`Unexpected ${t.length-s.offset} bytes after deserialized data`);return o}var Hs=Be.deserialize=Ha;function $a(r,e,t,n=Ue){const s=new n(t);return yr(r,e,s)}Us=Be.deserializeUnchecked=$a;var S={};Object.defineProperty(S,"__esModule",{value:!0});S.s16=S.s8=S.nu64be=S.u48be=S.u40be=S.u32be=S.u24be=S.u16be=ke=S.nu64=S.u48=S.u40=K=S.u32=S.u24=Fe=S.u16=se=S.u8=bt=S.offset=S.greedy=S.Constant=S.UTF8=S.CString=S.Blob=S.Boolean=S.BitField=S.BitStructure=S.VariantLayout=S.Union=S.UnionLayoutDiscriminator=S.UnionDiscriminator=S.Structure=S.Sequence=S.DoubleBE=S.Double=S.FloatBE=S.Float=S.NearInt64BE=S.NearInt64=S.NearUInt64BE=S.NearUInt64=S.IntBE=S.Int=S.UIntBE=S.UInt=S.OffsetLayout=S.GreedyCount=S.ExternalLayout=S.bindConstructorLayout=S.nameWithProperty=S.Layout=S.uint8ArrayToBuffer=S.checkUint8Array=void 0;S.constant=S.utf8=S.cstr=ge=S.blob=S.unionLayoutDiscriminator=S.union=Ce=S.seq=S.bits=q=S.struct=S.f64be=S.f64=S.f32be=S.f32=S.ns64be=S.s48be=S.s40be=S.s32be=S.s24be=S.s16be=Ne=S.ns64=S.s48=S.s40=S.s32=S.s24=void 0;const mr=Z;function zt(r){if(!(r instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}S.checkUint8Array=zt;function re(r){return zt(r),mr.Buffer.from(r.buffer,r.byteOffset,r.length)}S.uint8ArrayToBuffer=re;class ie{constructor(e,t){if(!Number.isInteger(e))throw new TypeError("span must be an integer");this.span=e,this.property=t}makeDestinationObject(){return{}}getSpan(e,t){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(e){const t=Object.create(this.constructor.prototype);return Object.assign(t,this),t.property=e,t}fromArray(e){}}S.Layout=ie;function wr(r,e){return e.property?r+"["+e.property+"]":r}S.nameWithProperty=wr;function Da(r,e){if(typeof r!="function")throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(r,"layout_"))throw new Error("Class is already bound to a layout");if(!(e&&e instanceof ie))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(e,"boundConstructor_"))throw new Error("layout is already bound to a constructor");r.layout_=e,e.boundConstructor_=r,e.makeDestinationObject=()=>new r,Object.defineProperty(r.prototype,"encode",{value(t,n){return e.encode(this,t,n)},writable:!0}),Object.defineProperty(r,"decode",{value(t,n){return e.decode(t,n)},writable:!0})}S.bindConstructorLayout=Da;class Oe extends ie{isCount(){throw new Error("ExternalLayout is abstract")}}S.ExternalLayout=Oe;class $s extends Oe{constructor(e=1,t){if(!Number.isInteger(e)||0>=e)throw new TypeError("elementSpan must be a (positive) integer");super(-1,t),this.elementSpan=e}isCount(){return!0}decode(e,t=0){zt(e);const n=e.length-t;return Math.floor(n/this.elementSpan)}encode(e,t,n){return 0}}S.GreedyCount=$s;class br extends Oe{constructor(e,t=0,n){if(!(e instanceof ie))throw new TypeError("layout must be a Layout");if(!Number.isInteger(t))throw new TypeError("offset must be integer or undefined");super(e.span,n||e.property),this.layout=e,this.offset=t}isCount(){return this.layout instanceof Me||this.layout instanceof je}decode(e,t=0){return this.layout.decode(e,t+this.offset)}encode(e,t,n=0){return this.layout.encode(e,t,n+this.offset)}}S.OffsetLayout=br;class Me extends ie{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return re(e).readUIntLE(t,this.span)}encode(e,t,n=0){return re(t).writeUIntLE(e,n,this.span),this.span}}S.UInt=Me;class je extends ie{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return re(e).readUIntBE(t,this.span)}encode(e,t,n=0){return re(t).writeUIntBE(e,n,this.span),this.span}}S.UIntBE=je;class xt extends ie{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return re(e).readIntLE(t,this.span)}encode(e,t,n=0){return re(t).writeIntLE(e,n,this.span),this.span}}S.Int=xt;class Kt extends ie{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return re(e).readIntBE(t,this.span)}encode(e,t,n=0){return re(t).writeIntBE(e,n,this.span),this.span}}S.IntBE=Kt;const Vn=Math.pow(2,32);function An(r){const e=Math.floor(r/Vn),t=r-e*Vn;return{hi32:e,lo32:t}}function In(r,e){return r*Vn+e}class Ds extends ie{constructor(e){super(8,e)}decode(e,t=0){const n=re(e),s=n.readUInt32LE(t),o=n.readUInt32LE(t+4);return In(o,s)}encode(e,t,n=0){const s=An(e),o=re(t);return o.writeUInt32LE(s.lo32,n),o.writeUInt32LE(s.hi32,n+4),8}}S.NearUInt64=Ds;class js extends ie{constructor(e){super(8,e)}decode(e,t=0){const n=re(e),s=n.readUInt32BE(t),o=n.readUInt32BE(t+4);return In(s,o)}encode(e,t,n=0){const s=An(e),o=re(t);return o.writeUInt32BE(s.hi32,n),o.writeUInt32BE(s.lo32,n+4),8}}S.NearUInt64BE=js;class Ws extends ie{constructor(e){super(8,e)}decode(e,t=0){const n=re(e),s=n.readUInt32LE(t),o=n.readInt32LE(t+4);return In(o,s)}encode(e,t,n=0){const s=An(e),o=re(t);return o.writeUInt32LE(s.lo32,n),o.writeInt32LE(s.hi32,n+4),8}}S.NearInt64=Ws;class Gs extends ie{constructor(e){super(8,e)}decode(e,t=0){const n=re(e),s=n.readInt32BE(t),o=n.readUInt32BE(t+4);return In(s,o)}encode(e,t,n=0){const s=An(e),o=re(t);return o.writeInt32BE(s.hi32,n),o.writeUInt32BE(s.lo32,n+4),8}}S.NearInt64BE=Gs;class Vs extends ie{constructor(e){super(4,e)}decode(e,t=0){return re(e).readFloatLE(t)}encode(e,t,n=0){return re(t).writeFloatLE(e,n),4}}S.Float=Vs;class Zs extends ie{constructor(e){super(4,e)}decode(e,t=0){return re(e).readFloatBE(t)}encode(e,t,n=0){return re(t).writeFloatBE(e,n),4}}S.FloatBE=Zs;class Ys extends ie{constructor(e){super(8,e)}decode(e,t=0){return re(e).readDoubleLE(t)}encode(e,t,n=0){return re(t).writeDoubleLE(e,n),8}}S.Double=Ys;class Xs extends ie{constructor(e){super(8,e)}decode(e,t=0){return re(e).readDoubleBE(t)}encode(e,t,n=0){return re(t).writeDoubleBE(e,n),8}}S.DoubleBE=Xs;class Js extends ie{constructor(e,t,n){if(!(e instanceof ie))throw new TypeError("elementLayout must be a Layout");if(!(t instanceof Oe&&t.isCount()||Number.isInteger(t)&&0<=t))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let s=-1;!(t instanceof Oe)&&0<e.span&&(s=t*e.span),super(s,n),this.elementLayout=e,this.count=t}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0,s=this.count;if(s instanceof Oe&&(s=s.decode(e,t)),0<this.elementLayout.span)n=s*this.elementLayout.span;else{let o=0;for(;o<s;)n+=this.elementLayout.getSpan(e,t+n),++o}return n}decode(e,t=0){const n=[];let s=0,o=this.count;for(o instanceof Oe&&(o=o.decode(e,t));s<o;)n.push(this.elementLayout.decode(e,t)),t+=this.elementLayout.getSpan(e,t),s+=1;return n}encode(e,t,n=0){const s=this.elementLayout,o=e.reduce((i,a)=>i+s.encode(a,t,n+i),0);return this.count instanceof Oe&&this.count.encode(e.length,t,n),o}}S.Sequence=Js;class Qs extends ie{constructor(e,t,n){if(!(Array.isArray(e)&&e.reduce((o,i)=>o&&i instanceof ie,!0)))throw new TypeError("fields must be array of Layout instances");typeof t=="boolean"&&n===void 0&&(n=t,t=void 0);for(const o of e)if(0>o.span&&o.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let s=-1;try{s=e.reduce((o,i)=>o+i.getSpan(),0)}catch{}super(s,t),this.fields=e,this.decodePrefixes=!!n}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;try{n=this.fields.reduce((s,o)=>{const i=o.getSpan(e,t);return t+=i,s+i},0)}catch{throw new RangeError("indeterminate span")}return n}decode(e,t=0){zt(e);const n=this.makeDestinationObject();for(const s of this.fields)if(s.property!==void 0&&(n[s.property]=s.decode(e,t)),t+=s.getSpan(e,t),this.decodePrefixes&&e.length===t)break;return n}encode(e,t,n=0){const s=n;let o=0,i=0;for(const a of this.fields){let c=a.span;if(i=0<c?c:0,a.property!==void 0){const u=e[a.property];u!==void 0&&(i=a.encode(u,t,n),0>c&&(c=a.getSpan(t,n)))}o=n,n+=c}return o+i-s}fromArray(e){const t=this.makeDestinationObject();for(const n of this.fields)n.property!==void 0&&0<e.length&&(t[n.property]=e.shift());return t}layoutFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}offsetOf(e){if(typeof e!="string")throw new TypeError("property must be string");let t=0;for(const n of this.fields){if(n.property===e)return t;0>n.span?t=-1:0<=t&&(t+=n.span)}}}S.Structure=Qs;class vr{constructor(e){this.property=e}decode(e,t){throw new Error("UnionDiscriminator is abstract")}encode(e,t,n){throw new Error("UnionDiscriminator is abstract")}}S.UnionDiscriminator=vr;class wn extends vr{constructor(e,t){if(!(e instanceof Oe&&e.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(t||e.property||"variant"),this.layout=e}decode(e,t){return this.layout.decode(e,t)}encode(e,t,n){return this.layout.encode(e,t,n)}}S.UnionLayoutDiscriminator=wn;class Sr extends ie{constructor(e,t,n){let s;if(e instanceof Me||e instanceof je)s=new wn(new br(e));else if(e instanceof Oe&&e.isCount())s=new wn(e);else if(e instanceof vr)s=e;else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(t===void 0&&(t=null),!(t===null||t instanceof ie))throw new TypeError("defaultLayout must be null or a Layout");if(t!==null){if(0>t.span)throw new Error("defaultLayout must have constant span");t.property===void 0&&(t=t.replicate("content"))}let o=-1;t&&(o=t.span,0<=o&&(e instanceof Me||e instanceof je)&&(o+=s.layout.span)),super(o,n),this.discriminator=s,this.usesPrefixDiscriminator=e instanceof Me||e instanceof je,this.defaultLayout=t,this.registry={};let i=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(a){return i(a)},this.configGetSourceVariant=function(a){i=a.bind(this)}}getSpan(e,t=0){if(0<=this.span)return this.span;const n=this.getVariant(e,t);if(!n)throw new Error("unable to determine span for unrecognized variant");return n.getSpan(e,t)}defaultGetSourceVariant(e){if(Object.prototype.hasOwnProperty.call(e,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(e,this.defaultLayout.property))return;const t=this.registry[e[this.discriminator.property]];if(t&&(!t.layout||t.property&&Object.prototype.hasOwnProperty.call(e,t.property)))return t}else for(const t in this.registry){const n=this.registry[t];if(n.property&&Object.prototype.hasOwnProperty.call(e,n.property))return n}throw new Error("unable to infer src variant")}decode(e,t=0){let n;const s=this.discriminator,o=s.decode(e,t),i=this.registry[o];if(i===void 0){const a=this.defaultLayout;let c=0;this.usesPrefixDiscriminator&&(c=s.layout.span),n=this.makeDestinationObject(),n[s.property]=o,n[a.property]=a.decode(e,t+c)}else n=i.decode(e,t);return n}encode(e,t,n=0){const s=this.getSourceVariant(e);if(s===void 0){const o=this.discriminator,i=this.defaultLayout;let a=0;return this.usesPrefixDiscriminator&&(a=o.layout.span),o.encode(e[o.property],t,n),a+i.encode(e[i.property],t,n+a)}return s.encode(e,t,n)}addVariant(e,t,n){const s=new eo(this,e,t,n);return this.registry[e]=s,s}getVariant(e,t=0){let n;return e instanceof Uint8Array?n=this.discriminator.decode(e,t):n=e,this.registry[n]}}S.Union=Sr;class eo extends ie{constructor(e,t,n,s){if(!(e instanceof Sr))throw new TypeError("union must be a Union");if(!Number.isInteger(t)||0>t)throw new TypeError("variant must be a (non-negative) integer");if(typeof n=="string"&&s===void 0&&(s=n,n=null),n){if(!(n instanceof ie))throw new TypeError("layout must be a Layout");if(e.defaultLayout!==null&&0<=n.span&&n.span>e.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof s!="string")throw new TypeError("variant must have a String property")}let o=e.span;0>e.span&&(o=n?n.span:0,0<=o&&e.usesPrefixDiscriminator&&(o+=e.discriminator.layout.span)),super(o,s),this.union=e,this.variant=t,this.layout=n||null}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span);let s=0;return this.layout&&(s=this.layout.getSpan(e,t+n)),n+s}decode(e,t=0){const n=this.makeDestinationObject();if(this!==this.union.getVariant(e,t))throw new Error("variant mismatch");let s=0;return this.union.usesPrefixDiscriminator&&(s=this.union.discriminator.layout.span),this.layout?n[this.property]=this.layout.decode(e,t+s):this.property?n[this.property]=!0:this.union.usesPrefixDiscriminator&&(n[this.union.discriminator.property]=this.variant),n}encode(e,t,n=0){let s=0;if(this.union.usesPrefixDiscriminator&&(s=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(e,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,t,n);let o=s;if(this.layout&&(this.layout.encode(e[this.property],t,n+s),o+=this.layout.getSpan(t,n+s),0<=this.union.span&&o>this.union.span))throw new Error("encoded variant overruns containing union");return o}fromArray(e){if(this.layout)return this.layout.fromArray(e)}}S.VariantLayout=eo;function Bt(r){return 0>r&&(r+=4294967296),r}class xr extends ie{constructor(e,t,n){if(!(e instanceof Me||e instanceof je))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof t=="string"&&n===void 0&&(n=t,t=!1),4<e.span)throw new RangeError("word cannot exceed 32 bits");super(e.span,n),this.word=e,this.msb=!!t,this.fields=[];let s=0;this._packedSetValue=function(o){return s=Bt(o),this},this._packedGetValue=function(){return s}}decode(e,t=0){const n=this.makeDestinationObject(),s=this.word.decode(e,t);this._packedSetValue(s);for(const o of this.fields)o.property!==void 0&&(n[o.property]=o.decode(e));return n}encode(e,t,n=0){const s=this.word.decode(t,n);this._packedSetValue(s);for(const o of this.fields)if(o.property!==void 0){const i=e[o.property];i!==void 0&&o.encode(i)}return this.word.encode(this._packedGetValue(),t,n)}addField(e,t){const n=new Er(this,e,t);return this.fields.push(n),n}addBoolean(e){const t=new to(this,e);return this.fields.push(t),t}fieldFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}}S.BitStructure=xr;class Er{constructor(e,t,n){if(!(e instanceof xr))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(t)||0>=t)throw new TypeError("bits must be positive integer");const s=8*e.span,o=e.fields.reduce((i,a)=>i+a.bits,0);if(t+o>s)throw new Error("bits too long for span remainder ("+(s-o)+" of "+s+" remain)");this.container=e,this.bits=t,this.valueMask=(1<<t)-1,t===32&&(this.valueMask=4294967295),this.start=o,this.container.msb&&(this.start=s-o-t),this.wordMask=Bt(this.valueMask<<this.start),this.property=n}decode(e,t){const n=this.container._packedGetValue();return Bt(n&this.wordMask)>>>this.start}encode(e){if(typeof e!="number"||!Number.isInteger(e)||e!==Bt(e&this.valueMask))throw new TypeError(wr("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const t=this.container._packedGetValue(),n=Bt(e<<this.start);this.container._packedSetValue(Bt(t&~this.wordMask)|n)}}S.BitField=Er;let to=class extends Er{constructor(e,t){super(e,1,t)}decode(e,t){return!!super.decode(e,t)}encode(e){typeof e=="boolean"&&(e=+e),super.encode(e)}};S.Boolean=to;class no extends ie{constructor(e,t){if(!(e instanceof Oe&&e.isCount()||Number.isInteger(e)&&0<=e))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let n=-1;e instanceof Oe||(n=e),super(n,t),this.length=e}getSpan(e,t){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),n}decode(e,t=0){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),re(e).slice(t,t+n)}encode(e,t,n){let s=this.length;if(this.length instanceof Oe&&(s=e.length),!(e instanceof Uint8Array&&s===e.length))throw new TypeError(wr("Blob.encode",this)+" requires (length "+s+") Uint8Array as src");if(n+s>t.length)throw new RangeError("encoding overruns Uint8Array");const o=re(e);return re(t).write(o.toString("hex"),n,s,"hex"),this.length instanceof Oe&&this.length.encode(s,t,n),s}}S.Blob=no;class ro extends ie{constructor(e){super(-1,e)}getSpan(e,t=0){zt(e);let n=t;for(;n<e.length&&e[n]!==0;)n+=1;return 1+n-t}decode(e,t=0){const n=this.getSpan(e,t);return re(e).slice(t,t+n-1).toString("utf-8")}encode(e,t,n=0){typeof e!="string"&&(e=String(e));const s=mr.Buffer.from(e,"utf8"),o=s.length;if(n+o>t.length)throw new RangeError("encoding overruns Buffer");const i=re(t);return s.copy(i,n),i[n+o]=0,o+1}}S.CString=ro;class so extends ie{constructor(e,t){if(typeof e=="string"&&t===void 0&&(t=e,e=void 0),e===void 0)e=-1;else if(!Number.isInteger(e))throw new TypeError("maxSpan must be an integer");super(-1,t),this.maxSpan=e}getSpan(e,t=0){return zt(e),e.length-t}decode(e,t=0){const n=this.getSpan(e,t);if(0<=this.maxSpan&&this.maxSpan<n)throw new RangeError("text length exceeds maxSpan");return re(e).slice(t,t+n).toString("utf-8")}encode(e,t,n=0){typeof e!="string"&&(e=String(e));const s=mr.Buffer.from(e,"utf8"),o=s.length;if(0<=this.maxSpan&&this.maxSpan<o)throw new RangeError("text length exceeds maxSpan");if(n+o>t.length)throw new RangeError("encoding overruns Buffer");return s.copy(re(t),n),o}}S.UTF8=so;class oo extends ie{constructor(e,t){super(0,t),this.value=e}decode(e,t){return this.value}encode(e,t,n){return 0}}S.Constant=oo;S.greedy=(r,e)=>new $s(r,e);var bt=S.offset=(r,e,t)=>new br(r,e,t),se=S.u8=r=>new Me(1,r),Fe=S.u16=r=>new Me(2,r);S.u24=r=>new Me(3,r);var K=S.u32=r=>new Me(4,r);S.u40=r=>new Me(5,r);S.u48=r=>new Me(6,r);var ke=S.nu64=r=>new Ds(r);S.u16be=r=>new je(2,r);S.u24be=r=>new je(3,r);S.u32be=r=>new je(4,r);S.u40be=r=>new je(5,r);S.u48be=r=>new je(6,r);S.nu64be=r=>new js(r);S.s8=r=>new xt(1,r);S.s16=r=>new xt(2,r);S.s24=r=>new xt(3,r);S.s32=r=>new xt(4,r);S.s40=r=>new xt(5,r);S.s48=r=>new xt(6,r);var Ne=S.ns64=r=>new Ws(r);S.s16be=r=>new Kt(2,r);S.s24be=r=>new Kt(3,r);S.s32be=r=>new Kt(4,r);S.s40be=r=>new Kt(5,r);S.s48be=r=>new Kt(6,r);S.ns64be=r=>new Gs(r);S.f32=r=>new Vs(r);S.f32be=r=>new Zs(r);S.f64=r=>new Ys(r);S.f64be=r=>new Xs(r);var q=S.struct=(r,e,t)=>new Qs(r,e,t);S.bits=(r,e,t)=>new xr(r,e,t);var Ce=S.seq=(r,e,t)=>new Js(r,e,t);S.union=(r,e,t)=>new Sr(r,e,t);S.unionLayoutDiscriminator=(r,e)=>new wn(r,e);var ge=S.blob=(r,e)=>new no(r,e);S.cstr=r=>new ro(r);S.utf8=(r,e)=>new so(r,e);S.constant=(r,e)=>new oo(r,e);var Qt={};Object.defineProperty(Qt,"__esModule",{value:!0});function ja(r){{const e=Buffer.from(r);e.reverse();const t=e.toString("hex");return t.length===0?BigInt(0):BigInt(`0x${t}`)}}var Wa=Qt.toBigIntLE=ja;function Ga(r){{const e=r.toString("hex");return e.length===0?BigInt(0):BigInt(`0x${e}`)}}Qt.toBigIntBE=Ga;function Va(r,e){{const t=r.toString(16),n=Buffer.from(t.padStart(e*2,"0").slice(0,e*2),"hex");return n.reverse(),n}}var Za=Qt.toBufferLE=Va;function Ya(r,e){{const t=r.toString(16);return Buffer.from(t.padStart(e*2,"0").slice(0,e*2),"hex")}}Qt.toBufferBE=Ya;class Xa extends TypeError{constructor(e,t){let n;const{message:s,...o}=e,{path:i}=e,a=i.length===0?s:"At path: "+i.join(".")+" -- "+s;super(a),Object.assign(this,o),this.name=this.constructor.name,this.failures=()=>{var c;return(c=n)!=null?c:n=[e,...t()]}}}function Ja(r){return ut(r)&&typeof r[Symbol.iterator]=="function"}function ut(r){return typeof r=="object"&&r!=null}function We(r){return typeof r=="string"?JSON.stringify(r):""+r}function Qa(r){const{done:e,value:t}=r.next();return e?void 0:t}function ec(r,e,t,n){if(r===!0)return;r===!1?r={}:typeof r=="string"&&(r={message:r});const{path:s,branch:o}=e,{type:i}=t,{refinement:a,message:c="Expected a value of type `"+i+"`"+(a?" with refinement `"+a+"`":"")+", but received: `"+We(n)+"`"}=r;return{value:n,type:i,refinement:a,key:s[s.length-1],path:s,branch:o,...r,message:c}}function*Xr(r,e,t,n){Ja(r)||(r=[r]);for(const s of r){const o=ec(s,e,t,n);o&&(yield o)}}function*_r(r,e,t={}){const{path:n=[],branch:s=[r],coerce:o=!1,mask:i=!1}=t,a={path:n,branch:s};if(o&&(r=e.coercer(r,a),i&&e.type!=="type"&&ut(e.schema)&&ut(r)&&!Array.isArray(r)))for(const u in r)e.schema[u]===void 0&&delete r[u];let c=!0;for(const u of e.validator(r,a))c=!1,yield[u,void 0];for(let[u,l,y]of e.entries(r,a)){const _=_r(l,y,{path:u===void 0?n:[...n,u],branch:u===void 0?s:[...s,l],coerce:o,mask:i});for(const p of _)p[0]?(c=!1,yield[p[0],void 0]):o&&(l=p[1],u===void 0?r=l:r instanceof Map?r.set(u,l):r instanceof Set?r.add(l):ut(r)&&(r[u]=l))}if(c)for(const u of e.refiner(r,a))c=!1,yield[u,void 0];c&&(yield[void 0,r])}let Qe=class{constructor(e){const{type:t,schema:n,validator:s,refiner:o,coercer:i=c=>c,entries:a=function*(){}}=e;this.type=t,this.schema=n,this.entries=a,this.coercer=i,s?this.validator=(c,u)=>{const l=s(c,u);return Xr(l,u,this,c)}:this.validator=()=>[],o?this.refiner=(c,u)=>{const l=o(c,u);return Xr(l,u,this,c)}:this.refiner=()=>[]}assert(e){return tc(e,this)}create(e){return T(e,this)}is(e){return io(e,this)}mask(e){return nc(e,this)}validate(e,t={}){return en(e,this,t)}};function tc(r,e){const t=en(r,e);if(t[0])throw t[0]}function T(r,e){const t=en(r,e,{coerce:!0});if(t[0])throw t[0];return t[1]}function nc(r,e){const t=en(r,e,{coerce:!0,mask:!0});if(t[0])throw t[0];return t[1]}function io(r,e){return!en(r,e)[0]}function en(r,e,t={}){const n=_r(r,e,t),s=Qa(n);return s[0]?[new Xa(s[0],function*(){for(const i of n)i[0]&&(yield i[0])}),void 0]:[void 0,s[1]]}function Et(r,e){return new Qe({type:r,schema:null,validator:e})}function rc(){return Et("any",()=>!0)}function P(r){return new Qe({type:"array",schema:r,*entries(e){if(r&&Array.isArray(e))for(const[t,n]of e.entries())yield[t,n,r]},coercer(e){return Array.isArray(e)?e.slice():e},validator(e){return Array.isArray(e)||"Expected an array value, but received: "+We(e)}})}function st(){return Et("boolean",r=>typeof r=="boolean")}function kr(r){return Et("instance",e=>e instanceof r||"Expected a `"+r.name+"` instance, but received: "+We(e))}function de(r){const e=We(r),t=typeof r;return new Qe({type:"literal",schema:t==="string"||t==="number"||t==="boolean"?r:null,validator(n){return n===r||"Expected the literal `"+e+"`, but received: "+We(n)}})}function sc(){return Et("never",()=>!1)}function L(r){return new Qe({...r,validator:(e,t)=>e===null||r.validator(e,t),refiner:(e,t)=>e===null||r.refiner(e,t)})}function b(){return Et("number",r=>typeof r=="number"&&!isNaN(r)||"Expected a number, but received: "+We(r))}function H(r){return new Qe({...r,validator:(e,t)=>e===void 0||r.validator(e,t),refiner:(e,t)=>e===void 0||r.refiner(e,t)})}function ao(r,e){return new Qe({type:"record",schema:null,*entries(t){if(ut(t))for(const n in t){const s=t[n];yield[n,n,r],yield[n,s,e]}},validator(t){return ut(t)||"Expected an object, but received: "+We(t)}})}function R(){return Et("string",r=>typeof r=="string"||"Expected a string, but received: "+We(r))}function Br(r){const e=sc();return new Qe({type:"tuple",schema:null,*entries(t){if(Array.isArray(t)){const n=Math.max(r.length,t.length);for(let s=0;s<n;s++)yield[s,t[s],r[s]||e]}},validator(t){return Array.isArray(t)||"Expected an array, but received: "+We(t)}})}function I(r){const e=Object.keys(r);return new Qe({type:"type",schema:r,*entries(t){if(ut(t))for(const n of e)yield[n,t[n],r[n]]},validator(t){return ut(t)||"Expected an object, but received: "+We(t)}})}function Pe(r){const e=r.map(t=>t.type).join(" | ");return new Qe({type:"union",schema:null,validator(t,n){const s=[];for(const o of r){const[...i]=_r(t,o,n),[a]=i;if(a[0])for(const[c]of i)c&&s.push(c);else return[]}return["Expected the value to satisfy a union of `"+e+"`, but received: "+We(t),...s]}})}function tn(){return Et("unknown",()=>!0)}function nn(r,e,t){return new Qe({...r,coercer:(n,s)=>io(n,e)?r.coercer(t(n,s),s):r.coercer(n,s)})}const oc=xs.v4,ic=function(r,e,t,n){if(typeof r!="string")throw new TypeError(r+" must be a string");n=n||{};const s=typeof n.version=="number"?n.version:2;if(s!==1&&s!==2)throw new TypeError(s+" must be 1 or 2");const o={method:r};if(s===2&&(o.jsonrpc="2.0"),e){if(typeof e!="object"&&!Array.isArray(e))throw new TypeError(e+" must be an object, array or omitted");o.params=e}if(typeof t>"u"){const i=typeof n.generator=="function"?n.generator:function(){return oc()};o.id=i(o,n)}else s===2&&t===null?n.notificationIdNull&&(o.id=null):o.id=t;return o};var ac=ic;const cc=xs.v4,uc=ac,Vt=function(r,e){if(!(this instanceof Vt))return new Vt(r,e);e||(e={}),this.options={reviver:typeof e.reviver<"u"?e.reviver:null,replacer:typeof e.replacer<"u"?e.replacer:null,generator:typeof e.generator<"u"?e.generator:function(){return cc()},version:typeof e.version<"u"?e.version:2,notificationIdNull:typeof e.notificationIdNull=="boolean"?e.notificationIdNull:!1},this.callServer=r};var lc=Vt;Vt.prototype.request=function(r,e,t,n){const s=this;let o=null;const i=Array.isArray(r)&&typeof e=="function";if(this.options.version===1&&i)throw new TypeError("JSON-RPC 1.0 does not support batching");if(i||!i&&r&&typeof r=="object"&&typeof e=="function")n=e,o=r;else{typeof t=="function"&&(n=t,t=void 0);const u=typeof n=="function";try{o=uc(r,e,t,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(l){if(u)return n(l);throw l}if(!u)return o}let c;try{c=JSON.stringify(o,this.options.replacer)}catch(u){return n(u)}return this.callServer(c,function(u,l){s._parseResponse(u,l,n)}),o};Vt.prototype._parseResponse=function(r,e,t){if(r){t(r);return}if(!e)return t();let n;try{n=JSON.parse(e,this.options.reviver)}catch(s){return t(s)}if(t.length===3)if(Array.isArray(n)){const s=function(i){return typeof i.error<"u"},o=function(i){return!s(i)};return t(null,n.filter(s),n.filter(o))}else return t(null,n.error,n.result);t(null,n)};const dc=Yt(lc);var co={},uo={exports:{}};(function(r){function e(t){return t&&t.__esModule?t:{default:t}}r.exports=e,r.exports.__esModule=!0,r.exports.default=r.exports})(uo);var lo=uo.exports;const fc=dt(Jo),hc=dt(Qo),fo=dt(ei),ho=dt(ti),po=dt(ni),go=dt(ri),yo=dt(si);var zn={exports:{}},Jr;function mo(){return Jr||(Jr=1,function(r){var e=Object.prototype.hasOwnProperty,t="~";function n(){}Object.create&&(n.prototype=Object.create(null),new n().__proto__||(t=!1));function s(c,u,l){this.fn=c,this.context=u,this.once=l||!1}function o(c,u,l,y,_){if(typeof l!="function")throw new TypeError("The listener must be a function");var p=new s(l,y||c,_),g=t?t+u:u;return c._events[g]?c._events[g].fn?c._events[g]=[c._events[g],p]:c._events[g].push(p):(c._events[g]=p,c._eventsCount++),c}function i(c,u){--c._eventsCount===0?c._events=new n:delete c._events[u]}function a(){this._events=new n,this._eventsCount=0}a.prototype.eventNames=function(){var u=[],l,y;if(this._eventsCount===0)return u;for(y in l=this._events)e.call(l,y)&&u.push(t?y.slice(1):y);return Object.getOwnPropertySymbols?u.concat(Object.getOwnPropertySymbols(l)):u},a.prototype.listeners=function(u){var l=t?t+u:u,y=this._events[l];if(!y)return[];if(y.fn)return[y.fn];for(var _=0,p=y.length,g=new Array(p);_<p;_++)g[_]=y[_].fn;return g},a.prototype.listenerCount=function(u){var l=t?t+u:u,y=this._events[l];return y?y.fn?1:y.length:0},a.prototype.emit=function(u,l,y,_,p,g){var d=t?t+u:u;if(!this._events[d])return!1;var f=this._events[d],m=arguments.length,v,h;if(f.fn){switch(f.once&&this.removeListener(u,f.fn,void 0,!0),m){case 1:return f.fn.call(f.context),!0;case 2:return f.fn.call(f.context,l),!0;case 3:return f.fn.call(f.context,l,y),!0;case 4:return f.fn.call(f.context,l,y,_),!0;case 5:return f.fn.call(f.context,l,y,_,p),!0;case 6:return f.fn.call(f.context,l,y,_,p,g),!0}for(h=1,v=new Array(m-1);h<m;h++)v[h-1]=arguments[h];f.fn.apply(f.context,v)}else{var k=f.length,w;for(h=0;h<k;h++)switch(f[h].once&&this.removeListener(u,f[h].fn,void 0,!0),m){case 1:f[h].fn.call(f[h].context);break;case 2:f[h].fn.call(f[h].context,l);break;case 3:f[h].fn.call(f[h].context,l,y);break;case 4:f[h].fn.call(f[h].context,l,y,_);break;default:if(!v)for(w=1,v=new Array(m-1);w<m;w++)v[w-1]=arguments[w];f[h].fn.apply(f[h].context,v)}}return!0},a.prototype.on=function(u,l,y){return o(this,u,l,y,!1)},a.prototype.once=function(u,l,y){return o(this,u,l,y,!0)},a.prototype.removeListener=function(u,l,y,_){var p=t?t+u:u;if(!this._events[p])return this;if(!l)return i(this,p),this;var g=this._events[p];if(g.fn)g.fn===l&&(!_||g.once)&&(!y||g.context===y)&&i(this,p);else{for(var d=0,f=[],m=g.length;d<m;d++)(g[d].fn!==l||_&&!g[d].once||y&&g[d].context!==y)&&f.push(g[d]);f.length?this._events[p]=f.length===1?f[0]:f:i(this,p)}return this},a.prototype.removeAllListeners=function(u){var l;return u?(l=t?t+u:u,this._events[l]&&i(this,l)):(this._events=new n,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=t,a.EventEmitter=a,r.exports=a}(zn)),zn.exports}(function(r){var e=lo;Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var t=e(oi),n=e(fc),s=e(hc),o=e(fo),i=e(ho),a=e(po),c=e(go),u=e(yo),l=mo();function y(d){var f=_();return function(){var v=(0,u.default)(d),h;if(f){var k=(0,u.default)(this).constructor;h=Reflect.construct(v,arguments,k)}else h=v.apply(this,arguments);return(0,c.default)(this,h)}}function _(){if(typeof Reflect>"u"||!Reflect.construct||Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch{return!1}}var p=function(d,f){var m={};for(var v in d)Object.prototype.hasOwnProperty.call(d,v)&&f.indexOf(v)<0&&(m[v]=d[v]);if(d!=null&&typeof Object.getOwnPropertySymbols=="function")for(var h=0,v=Object.getOwnPropertySymbols(d);h<v.length;h++)f.indexOf(v[h])<0&&Object.prototype.propertyIsEnumerable.call(d,v[h])&&(m[v[h]]=d[v[h]]);return m},g=function(d){(0,a.default)(m,d);var f=y(m);function m(v){var h,k=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"ws://localhost:8080",w=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},E=arguments.length>3?arguments[3]:void 0;(0,o.default)(this,m);var x=w.autoconnect,A=x===void 0?!0:x,W=w.reconnect,G=W===void 0?!0:W,j=w.reconnect_interval,ae=j===void 0?1e3:j,ce=w.max_reconnects,Te=ce===void 0?5:ce,C=p(w,["autoconnect","reconnect","reconnect_interval","max_reconnects"]);return h=f.call(this),h.webSocketFactory=v,h.queue={},h.rpc_id=0,h.address=k,h.autoconnect=A,h.ready=!1,h.reconnect=G,h.reconnect_timer_id=void 0,h.reconnect_interval=ae,h.max_reconnects=Te,h.rest_options=C,h.current_reconnects=0,h.generate_request_id=E||function(){return++h.rpc_id},h.autoconnect&&h._connect(h.address,Object.assign({autoconnect:h.autoconnect,reconnect:h.reconnect,reconnect_interval:h.reconnect_interval,max_reconnects:h.max_reconnects},h.rest_options)),h}return(0,i.default)(m,[{key:"connect",value:function(){this.socket||this._connect(this.address,Object.assign({autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects},this.rest_options))}},{key:"call",value:function(h,k,w,E){var x=this;return!E&&(0,s.default)(w)==="object"&&(E=w,w=null),new Promise(function(A,W){if(!x.ready)return W(new Error("socket not ready"));var G=x.generate_request_id(h,k),j={jsonrpc:"2.0",method:h,params:k||null,id:G};x.socket.send(JSON.stringify(j),E,function(ae){if(ae)return W(ae);x.queue[G]={promise:[A,W]},w&&(x.queue[G].timeout=setTimeout(function(){delete x.queue[G],W(new Error("reply timeout"))},w))})})}},{key:"login",value:function(){var v=(0,n.default)(t.default.mark(function k(w){var E;return t.default.wrap(function(A){for(;;)switch(A.prev=A.next){case 0:return A.next=2,this.call("rpc.login",w);case 2:if(E=A.sent,E){A.next=5;break}throw new Error("authentication failed");case 5:return A.abrupt("return",E);case 6:case"end":return A.stop()}},k,this)}));function h(k){return v.apply(this,arguments)}return h}()},{key:"listMethods",value:function(){var v=(0,n.default)(t.default.mark(function k(){return t.default.wrap(function(E){for(;;)switch(E.prev=E.next){case 0:return E.next=2,this.call("__listMethods");case 2:return E.abrupt("return",E.sent);case 3:case"end":return E.stop()}},k,this)}));function h(){return v.apply(this,arguments)}return h}()},{key:"notify",value:function(h,k){var w=this;return new Promise(function(E,x){if(!w.ready)return x(new Error("socket not ready"));var A={jsonrpc:"2.0",method:h,params:k||null};w.socket.send(JSON.stringify(A),function(W){if(W)return x(W);E()})})}},{key:"subscribe",value:function(){var v=(0,n.default)(t.default.mark(function k(w){var E;return t.default.wrap(function(A){for(;;)switch(A.prev=A.next){case 0:return typeof w=="string"&&(w=[w]),A.next=3,this.call("rpc.on",w);case 3:if(E=A.sent,!(typeof w=="string"&&E[w]!=="ok")){A.next=6;break}throw new Error("Failed subscribing to an event '"+w+"' with: "+E[w]);case 6:return A.abrupt("return",E);case 7:case"end":return A.stop()}},k,this)}));function h(k){return v.apply(this,arguments)}return h}()},{key:"unsubscribe",value:function(){var v=(0,n.default)(t.default.mark(function k(w){var E;return t.default.wrap(function(A){for(;;)switch(A.prev=A.next){case 0:return typeof w=="string"&&(w=[w]),A.next=3,this.call("rpc.off",w);case 3:if(E=A.sent,!(typeof w=="string"&&E[w]!=="ok")){A.next=6;break}throw new Error("Failed unsubscribing from an event with: "+E);case 6:return A.abrupt("return",E);case 7:case"end":return A.stop()}},k,this)}));function h(k){return v.apply(this,arguments)}return h}()},{key:"close",value:function(h,k){this.socket.close(h||1e3,k)}},{key:"_connect",value:function(h,k){var w=this;clearTimeout(this.reconnect_timer_id),this.socket=this.webSocketFactory(h,k),this.socket.addEventListener("open",function(){w.ready=!0,w.emit("open"),w.current_reconnects=0}),this.socket.addEventListener("message",function(E){var x=E.data;x instanceof ArrayBuffer&&(x=Buffer.from(x).toString());try{x=JSON.parse(x)}catch{return}if(x.notification&&w.listeners(x.notification).length){if(!Object.keys(x.params).length)return w.emit(x.notification);var A=[x.notification];if(x.params.constructor===Object)A.push(x.params);else for(var W=0;W<x.params.length;W++)A.push(x.params[W]);return Promise.resolve().then(function(){w.emit.apply(w,A)})}if(!w.queue[x.id])return x.method&&x.params?Promise.resolve().then(function(){w.emit(x.method,x.params)}):void 0;"error"in x=="result"in x&&w.queue[x.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),w.queue[x.id].timeout&&clearTimeout(w.queue[x.id].timeout),x.error?w.queue[x.id].promise[1](x.error):w.queue[x.id].promise[0](x.result),delete w.queue[x.id]}),this.socket.addEventListener("error",function(E){return w.emit("error",E)}),this.socket.addEventListener("close",function(E){var x=E.code,A=E.reason;w.ready&&setTimeout(function(){return w.emit("close",x,A)},0),w.ready=!1,w.socket=void 0,x!==1e3&&(w.current_reconnects++,w.reconnect&&(w.max_reconnects>w.current_reconnects||w.max_reconnects===0)&&(w.reconnect_timer_id=setTimeout(function(){return w._connect(h,k)},w.reconnect_interval)))})}}]),m}(l.EventEmitter);r.default=g})(co);const pc=Yt(co);var wo={};(function(r){var e=lo;Object.defineProperty(r,"__esModule",{value:!0}),r.default=y;var t=e(fo),n=e(ho),s=e(po),o=e(go),i=e(yo),a=mo();function c(_){var p=u();return function(){var d=(0,i.default)(_),f;if(p){var m=(0,i.default)(this).constructor;f=Reflect.construct(d,arguments,m)}else f=d.apply(this,arguments);return(0,o.default)(this,f)}}function u(){if(typeof Reflect>"u"||!Reflect.construct||Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch{return!1}}var l=function(_){(0,s.default)(g,_);var p=c(g);function g(d,f,m){var v;return(0,t.default)(this,g),v=p.call(this),v.socket=new window.WebSocket(d,m),v.socket.onopen=function(){return v.emit("open")},v.socket.onmessage=function(h){return v.emit("message",h.data)},v.socket.onerror=function(h){return v.emit("error",h)},v.socket.onclose=function(h){v.emit("close",h.code,h.reason)},v}return(0,n.default)(g,[{key:"send",value:function(f,m,v){var h=v||m;try{this.socket.send(f),h()}catch(k){h(k)}}},{key:"close",value:function(f,m){this.socket.close(f,m)}},{key:"addEventListener",value:function(f,m,v){this.socket.addEventListener(f,m,v)}}]),g}(a.EventEmitter);function y(_,p){return new l(_,p)}})(wo);const gc=Yt(wo),[bo,vo,So]=[[],[],[]],yc=BigInt(0),$t=BigInt(1),mc=BigInt(2),wc=BigInt(7),bc=BigInt(256),vc=BigInt(113);for(let r=0,e=$t,t=1,n=0;r<24;r++){[t,n]=[n,(2*t+3*n)%5],bo.push(2*(5*n+t)),vo.push((r+1)*(r+2)/2%64);let s=yc;for(let o=0;o<7;o++)e=(e<<$t^(e>>wc)*vc)%bc,e&mc&&(s^=$t<<($t<<BigInt(o))-$t);So.push(s)}const[Sc,xc]=$.split(So,!0),Qr=(r,e,t)=>t>32?$.rotlBH(r,e,t):$.rotlSH(r,e,t),es=(r,e,t)=>t>32?$.rotlBL(r,e,t):$.rotlSL(r,e,t);function Ec(r,e=24){const t=new Uint32Array(10);for(let n=24-e;n<24;n++){for(let i=0;i<10;i++)t[i]=r[i]^r[i+10]^r[i+20]^r[i+30]^r[i+40];for(let i=0;i<10;i+=2){const a=(i+8)%10,c=(i+2)%10,u=t[c],l=t[c+1],y=Qr(u,l,1)^t[a],_=es(u,l,1)^t[a+1];for(let p=0;p<50;p+=10)r[i+p]^=y,r[i+p+1]^=_}let s=r[2],o=r[3];for(let i=0;i<24;i++){const a=vo[i],c=Qr(s,o,a),u=es(s,o,a),l=bo[i];s=r[l],o=r[l+1],r[l]=c,r[l+1]=u}for(let i=0;i<50;i+=10){for(let a=0;a<10;a++)t[a]=r[i+a];for(let a=0;a<10;a++)r[i+a]^=~t[(a+2)%10]&t[(a+4)%10]}r[0]^=Sc[n],r[1]^=xc[n]}t.fill(0)}class Rn extends ks{constructor(e,t,n,s=!1,o=24){if(super(),this.blockLen=e,this.suffix=t,this.outputLen=n,this.enableXOF=s,this.rounds=o,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,Ve.number(n),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=ui(this.state)}keccak(){Ec(this.state32,this.rounds),this.posOut=0,this.pos=0}update(e){Ve.exists(this);const{blockLen:t,state:n}=this;e=Bs(e);const s=e.length;for(let o=0;o<s;){const i=Math.min(t-this.pos,s-o);for(let a=0;a<i;a++)n[this.pos++]^=e[o++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:t,pos:n,blockLen:s}=this;e[n]^=t,t&128&&n===s-1&&this.keccak(),e[s-1]^=128,this.keccak()}writeInto(e){Ve.exists(this,!1),Ve.bytes(e),this.finish();const t=this.state,{blockLen:n}=this;for(let s=0,o=e.length;s<o;){this.posOut>=n&&this.keccak();const i=Math.min(n-this.posOut,o-s);e.set(t.subarray(this.posOut,this.posOut+i),s),this.posOut+=i,s+=i}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return Ve.number(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(Ve.output(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:t,suffix:n,outputLen:s,rounds:o,enableXOF:i}=this;return e||(e=new Rn(t,n,s,i,o)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=o,e.suffix=n,e.outputLen=s,e.enableXOF=i,e.destroyed=this.destroyed,e}}const ft=(r,e,t)=>Jt(()=>new Rn(e,r,t));ft(6,144,224/8);ft(6,136,256/8);ft(6,104,384/8);ft(6,72,512/8);ft(1,144,224/8);ft(1,136,256/8);ft(1,104,384/8);ft(1,72,512/8);const xo=(r,e,t)=>ci((n={})=>new Rn(e,r,n.dkLen===void 0?t:n.dkLen,!0));xo(31,168,128/8);xo(31,136,256/8);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function _c(r){const e=dr(r);qt(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:n,a:s}=e;if(t){if(!n.eql(s,n.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:kc,hexToBytes:Bc}=Gi,mt={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(r){const{Err:e}=mt;if(r.length<2||r[0]!==2)throw new e("Invalid signature integer tag");const t=r[1],n=r.subarray(2,t+2);if(!t||n.length!==t)throw new e("Invalid signature integer: wrong length");if(n[0]&128)throw new e("Invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return{d:kc(n),l:r.subarray(t+2)}},toSig(r){const{Err:e}=mt,t=typeof r=="string"?Bc(r):r;if(!(t instanceof Uint8Array))throw new Error("ui8a expected");let n=t.length;if(n<2||t[0]!=48)throw new e("Invalid signature tag");if(t[1]!==n-2)throw new e("Invalid signature: incorrect length");const{d:s,l:o}=mt._parseInt(t.subarray(2)),{d:i,l:a}=mt._parseInt(o);if(a.length)throw new e("Invalid signature: left bytes after parsing");return{r:s,s:i}},hexFromSig(r){const e=u=>Number.parseInt(u[0],16)&8?"00"+u:u,t=u=>{const l=u.toString(16);return l.length&1?`0${l}`:l},n=e(t(r.s)),s=e(t(r.r)),o=n.length/2,i=s.length/2,a=t(o),c=t(i);return`30${t(i+o+4)}02${c}${s}02${a}${n}`}},nt=BigInt(0),qe=BigInt(1);BigInt(2);const ts=BigInt(3);BigInt(4);function Ac(r){const e=_c(r),{Fp:t}=e,n=e.toBytes||((g,d,f)=>{const m=d.toAffine();return St(Uint8Array.from([4]),t.toBytes(m.x),t.toBytes(m.y))}),s=e.fromBytes||(g=>{const d=g.subarray(1),f=t.fromBytes(d.subarray(0,t.BYTES)),m=t.fromBytes(d.subarray(t.BYTES,2*t.BYTES));return{x:f,y:m}});function o(g){const{a:d,b:f}=e,m=t.sqr(g),v=t.mul(m,g);return t.add(t.add(v,t.mul(g,d)),f)}if(!t.eql(t.sqr(e.Gy),o(e.Gx)))throw new Error("bad generator point: equation left != right");function i(g){return typeof g=="bigint"&&nt<g&&g<e.n}function a(g){if(!i(g))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function c(g){const{allowedPrivateKeyLengths:d,nByteLength:f,wrapPrivateKey:m,n:v}=e;if(d&&typeof g!="bigint"){if(g instanceof Uint8Array&&(g=vt(g)),typeof g!="string"||!d.includes(g.length))throw new Error("Invalid key");g=g.padStart(f*2,"0")}let h;try{h=typeof g=="bigint"?g:wt(ve("private key",g,f))}catch{throw new Error(`private key must be ${f} bytes, hex or bigint, not ${typeof g}`)}return m&&(h=ue(h,v)),a(h),h}const u=new Map;function l(g){if(!(g instanceof y))throw new Error("ProjectivePoint expected")}class y{constructor(d,f,m){if(this.px=d,this.py=f,this.pz=m,d==null||!t.isValid(d))throw new Error("x required");if(f==null||!t.isValid(f))throw new Error("y required");if(m==null||!t.isValid(m))throw new Error("z required")}static fromAffine(d){const{x:f,y:m}=d||{};if(!d||!t.isValid(f)||!t.isValid(m))throw new Error("invalid affine point");if(d instanceof y)throw new Error("projective point not allowed");const v=h=>t.eql(h,t.ZERO);return v(f)&&v(m)?y.ZERO:new y(f,m,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(d){const f=t.invertBatch(d.map(m=>m.pz));return d.map((m,v)=>m.toAffine(f[v])).map(y.fromAffine)}static fromHex(d){const f=y.fromAffine(s(ve("pointHex",d)));return f.assertValidity(),f}static fromPrivateKey(d){return y.BASE.multiply(c(d))}_setWindowSize(d){this._WINDOW_SIZE=d,u.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint)return;throw new Error("bad point: ZERO")}const{x:d,y:f}=this.toAffine();if(!t.isValid(d)||!t.isValid(f))throw new Error("bad point: x or y not FE");const m=t.sqr(f),v=o(d);if(!t.eql(m,v))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:d}=this.toAffine();if(t.isOdd)return!t.isOdd(d);throw new Error("Field doesn't support isOdd")}equals(d){l(d);const{px:f,py:m,pz:v}=this,{px:h,py:k,pz:w}=d,E=t.eql(t.mul(f,w),t.mul(h,v)),x=t.eql(t.mul(m,w),t.mul(k,v));return E&&x}negate(){return new y(this.px,t.neg(this.py),this.pz)}double(){const{a:d,b:f}=e,m=t.mul(f,ts),{px:v,py:h,pz:k}=this;let w=t.ZERO,E=t.ZERO,x=t.ZERO,A=t.mul(v,v),W=t.mul(h,h),G=t.mul(k,k),j=t.mul(v,h);return j=t.add(j,j),x=t.mul(v,k),x=t.add(x,x),w=t.mul(d,x),E=t.mul(m,G),E=t.add(w,E),w=t.sub(W,E),E=t.add(W,E),E=t.mul(w,E),w=t.mul(j,w),x=t.mul(m,x),G=t.mul(d,G),j=t.sub(A,G),j=t.mul(d,j),j=t.add(j,x),x=t.add(A,A),A=t.add(x,A),A=t.add(A,G),A=t.mul(A,j),E=t.add(E,A),G=t.mul(h,k),G=t.add(G,G),A=t.mul(G,j),w=t.sub(w,A),x=t.mul(G,W),x=t.add(x,x),x=t.add(x,x),new y(w,E,x)}add(d){l(d);const{px:f,py:m,pz:v}=this,{px:h,py:k,pz:w}=d;let E=t.ZERO,x=t.ZERO,A=t.ZERO;const W=e.a,G=t.mul(e.b,ts);let j=t.mul(f,h),ae=t.mul(m,k),ce=t.mul(v,w),Te=t.add(f,m),C=t.add(h,k);Te=t.mul(Te,C),C=t.add(j,ae),Te=t.sub(Te,C),C=t.add(f,v);let U=t.add(h,w);return C=t.mul(C,U),U=t.add(j,ce),C=t.sub(C,U),U=t.add(m,v),E=t.add(k,w),U=t.mul(U,E),E=t.add(ae,ce),U=t.sub(U,E),A=t.mul(W,C),E=t.mul(G,ce),A=t.add(E,A),E=t.sub(ae,A),A=t.add(ae,A),x=t.mul(E,A),ae=t.add(j,j),ae=t.add(ae,j),ce=t.mul(W,ce),C=t.mul(G,C),ae=t.add(ae,ce),ce=t.sub(j,ce),ce=t.mul(W,ce),C=t.add(C,ce),j=t.mul(ae,C),x=t.add(x,j),j=t.mul(U,C),E=t.mul(Te,E),E=t.sub(E,j),j=t.mul(Te,ae),A=t.mul(U,A),A=t.add(A,j),new y(E,x,A)}subtract(d){return this.add(d.negate())}is0(){return this.equals(y.ZERO)}wNAF(d){return p.wNAFCached(this,u,d,f=>{const m=t.invertBatch(f.map(v=>v.pz));return f.map((v,h)=>v.toAffine(m[h])).map(y.fromAffine)})}multiplyUnsafe(d){const f=y.ZERO;if(d===nt)return f;if(a(d),d===qe)return this;const{endo:m}=e;if(!m)return p.unsafeLadder(this,d);let{k1neg:v,k1:h,k2neg:k,k2:w}=m.splitScalar(d),E=f,x=f,A=this;for(;h>nt||w>nt;)h&qe&&(E=E.add(A)),w&qe&&(x=x.add(A)),A=A.double(),h>>=qe,w>>=qe;return v&&(E=E.negate()),k&&(x=x.negate()),x=new y(t.mul(x.px,m.beta),x.py,x.pz),E.add(x)}multiply(d){a(d);let f=d,m,v;const{endo:h}=e;if(h){const{k1neg:k,k1:w,k2neg:E,k2:x}=h.splitScalar(f);let{p:A,f:W}=this.wNAF(w),{p:G,f:j}=this.wNAF(x);A=p.constTimeNegate(k,A),G=p.constTimeNegate(E,G),G=new y(t.mul(G.px,h.beta),G.py,G.pz),m=A.add(G),v=W.add(j)}else{const{p:k,f:w}=this.wNAF(f);m=k,v=w}return y.normalizeZ([m,v])[0]}multiplyAndAddUnsafe(d,f,m){const v=y.BASE,h=(w,E)=>E===nt||E===qe||!w.equals(v)?w.multiplyUnsafe(E):w.multiply(E),k=h(this,f).add(h(d,m));return k.is0()?void 0:k}toAffine(d){const{px:f,py:m,pz:v}=this,h=this.is0();d==null&&(d=h?t.ONE:t.inv(v));const k=t.mul(f,d),w=t.mul(m,d),E=t.mul(v,d);if(h)return{x:t.ZERO,y:t.ZERO};if(!t.eql(E,t.ONE))throw new Error("invZ was invalid");return{x:k,y:w}}isTorsionFree(){const{h:d,isTorsionFree:f}=e;if(d===qe)return!0;if(f)return f(y,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:d,clearCofactor:f}=e;return d===qe?this:f?f(y,this):this.multiplyUnsafe(e.h)}toRawBytes(d=!0){return this.assertValidity(),n(y,this,d)}toHex(d=!0){return vt(this.toRawBytes(d))}}y.BASE=new y(e.Gx,e.Gy,t.ONE),y.ZERO=new y(t.ZERO,t.ONE,t.ZERO);const _=e.nBitLength,p=Ps(y,e.endo?Math.ceil(_/2):_);return{CURVE:e,ProjectivePoint:y,normPrivateKeyToScalar:c,weierstrassEquation:o,isWithinCurveOrder:i}}function Ic(r){const e=dr(r);return qt(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function Rc(r){const e=Ic(r),{Fp:t,n}=e,s=t.BYTES+1,o=2*t.BYTES+1;function i(C){return nt<C&&C<t.ORDER}function a(C){return ue(C,n)}function c(C){return Wn(C,n)}const{ProjectivePoint:u,normPrivateKeyToScalar:l,weierstrassEquation:y,isWithinCurveOrder:_}=Ac({...e,toBytes(C,U,Y){const O=U.toAffine(),B=t.toBytes(O.x),N=St;return Y?N(Uint8Array.from([U.hasEvenY()?2:3]),B):N(Uint8Array.from([4]),B,t.toBytes(O.y))},fromBytes(C){const U=C.length,Y=C[0],O=C.subarray(1);if(U===s&&(Y===2||Y===3)){const B=wt(O);if(!i(B))throw new Error("Point is not on curve");const N=y(B);let z=t.sqrt(N);const D=(z&qe)===qe;return(Y&1)===1!==D&&(z=t.neg(z)),{x:B,y:z}}else if(U===o&&Y===4){const B=t.fromBytes(O.subarray(0,t.BYTES)),N=t.fromBytes(O.subarray(t.BYTES,2*t.BYTES));return{x:B,y:N}}else throw new Error(`Point of length ${U} was invalid. Expected ${s} compressed bytes or ${o} uncompressed bytes`)}}),p=C=>vt(Ct(C,e.nByteLength));function g(C){const U=n>>qe;return C>U}function d(C){return g(C)?a(-C):C}const f=(C,U,Y)=>wt(C.slice(U,Y));class m{constructor(U,Y,O){this.r=U,this.s=Y,this.recovery=O,this.assertValidity()}static fromCompact(U){const Y=e.nByteLength;return U=ve("compactSignature",U,Y*2),new m(f(U,0,Y),f(U,Y,2*Y))}static fromDER(U){const{r:Y,s:O}=mt.toSig(ve("DER",U));return new m(Y,O)}assertValidity(){if(!_(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!_(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(U){return new m(this.r,this.s,U)}recoverPublicKey(U){const{r:Y,s:O,recovery:B}=this,N=x(ve("msgHash",U));if(B==null||![0,1,2,3].includes(B))throw new Error("recovery id invalid");const z=B===2||B===3?Y+e.n:Y;if(z>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const D=B&1?"03":"02",X=u.fromHex(D+p(z)),Q=c(z),oe=a(-N*Q),te=a(O*Q),ne=u.BASE.multiplyAndAddUnsafe(X,oe,te);if(!ne)throw new Error("point at infinify");return ne.assertValidity(),ne}hasHighS(){return g(this.s)}normalizeS(){return this.hasHighS()?new m(this.r,a(-this.s),this.recovery):this}toDERRawBytes(){return Ot(this.toDERHex())}toDERHex(){return mt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return Ot(this.toCompactHex())}toCompactHex(){return p(this.r)+p(this.s)}}const v={isValidPrivateKey(C){try{return l(C),!0}catch{return!1}},normPrivateKeyToScalar:l,randomPrivateKey:()=>{const C=e.randomBytes(t.BYTES+8),U=sa(C,n);return Ct(U,e.nByteLength)},precompute(C=8,U=u.BASE){return U._setWindowSize(C),U.multiply(BigInt(3)),U}};function h(C,U=!0){return u.fromPrivateKey(C).toRawBytes(U)}function k(C){const U=C instanceof Uint8Array,Y=typeof C=="string",O=(U||Y)&&C.length;return U?O===s||O===o:Y?O===2*s||O===2*o:C instanceof u}function w(C,U,Y=!0){if(k(C))throw new Error("first arg must be private key");if(!k(U))throw new Error("second arg must be public key");return u.fromHex(U).multiply(l(C)).toRawBytes(Y)}const E=e.bits2int||function(C){const U=wt(C),Y=C.length*8-e.nBitLength;return Y>0?U>>BigInt(Y):U},x=e.bits2int_modN||function(C){return a(E(C))},A=ur(e.nBitLength);function W(C){if(typeof C!="bigint")throw new Error("bigint expected");if(!(nt<=C&&C<A))throw new Error(`bigint expected < 2^${e.nBitLength}`);return Ct(C,e.nByteLength)}function G(C,U,Y=j){if(["recovered","canonical"].some(he=>he in Y))throw new Error("sign() legacy options not supported");const{hash:O,randomBytes:B}=e;let{lowS:N,prehash:z,extraEntropy:D}=Y;N==null&&(N=!0),C=ve("msgHash",C),z&&(C=ve("prehashed msgHash",O(C)));const X=x(C),Q=l(U),oe=[W(Q),W(X)];if(D!=null){const he=D===!0?B(t.BYTES):D;oe.push(ve("extraEntropy",he,t.BYTES))}const te=St(...oe),ne=X;function we(he){const Ee=E(he);if(!_(Ee))return;const _e=c(Ee),Ie=u.BASE.multiply(Ee).toAffine(),ye=a(Ie.x);if(ye===nt)return;const He=a(_e*a(ne+ye*Q));if(He===nt)return;let ht=(Ie.x===ye?0:2)|Number(Ie.y&qe),Ht=He;return N&&g(He)&&(Ht=d(He),ht^=1),new m(ye,Ht,ht)}return{seed:te,k2sig:we}}const j={lowS:e.lowS,prehash:!1},ae={lowS:e.lowS,prehash:!1};function ce(C,U,Y=j){const{seed:O,k2sig:B}=G(C,U,Y),N=e;return Ts(N.hash.outputLen,N.nByteLength,N.hmac)(O,B)}u.BASE._setWindowSize(8);function Te(C,U,Y,O=ae){var Ie;const B=C;if(U=ve("msgHash",U),Y=ve("publicKey",Y),"strict"in O)throw new Error("options.strict was renamed to lowS");const{lowS:N,prehash:z}=O;let D,X;try{if(typeof B=="string"||B instanceof Uint8Array)try{D=m.fromDER(B)}catch(ye){if(!(ye instanceof mt.Err))throw ye;D=m.fromCompact(B)}else if(typeof B=="object"&&typeof B.r=="bigint"&&typeof B.s=="bigint"){const{r:ye,s:He}=B;D=new m(ye,He)}else throw new Error("PARSE");X=u.fromHex(Y)}catch(ye){if(ye.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(N&&D.hasHighS())return!1;z&&(U=e.hash(U));const{r:Q,s:oe}=D,te=x(U),ne=c(oe),we=a(te*ne),he=a(Q*ne),Ee=(Ie=u.BASE.multiplyAndAddUnsafe(X,we,he))==null?void 0:Ie.toAffine();return Ee?a(Ee.x)===Q:!1}return{CURVE:e,getPublicKey:h,getSharedSecret:w,sign:ce,verify:Te,ProjectivePoint:u,Signature:m,utils:v}}class Eo extends ks{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,Ve.hash(e);const n=Bs(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(n.length>s?e.create().update(n).digest():n);for(let i=0;i<o.length;i++)o[i]^=54;this.iHash.update(o),this.oHash=e.create();for(let i=0;i<o.length;i++)o[i]^=106;this.oHash.update(o),o.fill(0)}update(e){return Ve.exists(this),this.iHash.update(e),this}digestInto(e){Ve.exists(this),Ve.bytes(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:n,finished:s,destroyed:o,blockLen:i,outputLen:a}=this;return e=e,e.finished=s,e.destroyed=o,e.blockLen=i,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const _o=(r,e,t)=>new Eo(r,e).update(t).digest();_o.create=(r,e)=>new Eo(r,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Cc(r){return{hash:r,hmac:(e,...t)=>_o(r,e,_s(...t)),randomBytes:Es}}function Tc(r,e){const t=n=>Rc({...r,...Cc(n)});return Object.freeze({...t(e),create:t})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ko=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),ns=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Oc=BigInt(1),Zn=BigInt(2),rs=(r,e)=>(r+e/Zn)/e;function Pc(r){const e=ko,t=BigInt(3),n=BigInt(6),s=BigInt(11),o=BigInt(22),i=BigInt(23),a=BigInt(44),c=BigInt(88),u=r*r*r%e,l=u*u*r%e,y=pe(l,t,e)*l%e,_=pe(y,t,e)*l%e,p=pe(_,Zn,e)*u%e,g=pe(p,s,e)*p%e,d=pe(g,o,e)*g%e,f=pe(d,a,e)*d%e,m=pe(f,c,e)*f%e,v=pe(m,a,e)*d%e,h=pe(v,t,e)*l%e,k=pe(h,i,e)*g%e,w=pe(k,n,e)*u%e,E=pe(w,Zn,e);if(!Yn.eql(Yn.sqr(E),r))throw new Error("Cannot find square root");return E}const Yn=Os(ko,void 0,void 0,{sqrt:Pc}),Ar=Tc({a:BigInt(0),b:BigInt(7),Fp:Yn,n:ns,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:r=>{const e=ns,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-Oc*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=t,i=BigInt("0x100000000000000000000000000000000"),a=rs(o*r,e),c=rs(-n*r,e);let u=ue(r-a*t-c*s,e),l=ue(-a*n-c*o,e);const y=u>i,_=l>i;if(y&&(u=e-u),_&&(l=e-l),u>i||l>i)throw new Error("splitScalar: Endomorphism failed, k="+r);return{k1neg:y,k1:u,k2neg:_,k2:l}}}},$n);BigInt(0);Ar.ProjectivePoint;Ft.utils.randomPrivateKey;const ss=()=>{const r=Ft.utils.randomPrivateKey(),e=Xn(r),t=new Uint8Array(64);return t.set(r),t.set(e,32),{publicKey:e,secretKey:t}},Xn=Ft.getPublicKey;function os(r){try{return Ft.ExtendedPoint.fromHex(r),!0}catch{return!1}}const Lc=(r,e)=>Ft.sign(r,e.slice(0,32)),Nc=Ft.verify,Lt=r=>Z.Buffer.isBuffer(r)?r:r instanceof Uint8Array?Z.Buffer.from(r.buffer,r.byteOffset,r.byteLength):Z.Buffer.from(r);class Uc{constructor(e){Object.assign(this,e)}encode(){return Z.Buffer.from(Ms(dn,this))}static decode(e){return Hs(dn,this,e)}static decodeUnchecked(e){return Us(dn,this,e)}}const dn=new Map;let Bo;const qc=32,Ze=32;function Fc(r){return r._bn!==void 0}let is=1;Bo=Symbol.toStringTag;class M extends Uc{constructor(e){if(super({}),this._bn=void 0,Fc(e))this._bn=e._bn;else{if(typeof e=="string"){const t=Ae.decode(e);if(t.length!=Ze)throw new Error("Invalid public key input");this._bn=new $r(t)}else this._bn=new $r(e);if(this._bn.byteLength()>Ze)throw new Error("Invalid public key input")}}static unique(){const e=new M(is);return is+=1,new M(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return Ae.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(Z.Buffer);if(e.length===Ze)return e;const t=Z.Buffer.alloc(32);return e.copy(t,32-e.length),t}get[Bo](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,n){const s=Z.Buffer.concat([e.toBuffer(),Z.Buffer.from(t),n.toBuffer()]),o=$n(s);return new M(o)}static createProgramAddressSync(e,t){let n=Z.Buffer.alloc(0);e.forEach(function(o){if(o.length>qc)throw new TypeError("Max seed length exceeded");n=Z.Buffer.concat([n,Lt(o)])}),n=Z.Buffer.concat([n,t.toBuffer(),Z.Buffer.from("ProgramDerivedAddress")]);const s=$n(n);if(os(s))throw new Error("Invalid seeds, address must fall off the curve");return new M(s)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let n=255,s;for(;n!=0;){try{const o=e.concat(Z.Buffer.from([n]));s=this.createProgramAddressSync(o,t)}catch(o){if(o instanceof TypeError)throw o;n--;continue}return[s,n]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){const t=new M(e);return os(t.toBytes())}}M.default=new M("11111111111111111111111111111111");dn.set(M,{kind:"struct",fields:[["_bn","u256"]]});new M("BPFLoader1111111111111111111111111111111111");const Tt=1280-40-8,Ao=127,Jn=64;class Io extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Io.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class Ro extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Ro.prototype,"name",{value:"TransactionExpiredTimeoutError"});class jt extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(jt.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class bn{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>255+1)throw new Error("Account index overflow encountered during compilation");const n=new Map;this.keySegments().flat().forEach((o,i)=>{n.set(o.toBase58(),i)});const s=o=>{const i=n.get(o.toBase58());if(i===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return i};return e.map(o=>({programIdIndex:s(o.programId),accountKeyIndexes:o.keys.map(i=>s(i.pubkey)),data:o.data}))}}const J=(r="publicKey")=>ge(32,r),It=(r="string")=>{const e=q([K("length"),K("lengthPadding"),ge(bt(K(),-8),"chars")],r),t=e.decode.bind(e),n=e.encode.bind(e),s=e;return s.decode=(o,i)=>t(o,i).chars.toString(),s.encode=(o,i,a)=>{const c={chars:Z.Buffer.from(o,"utf8")};return n(c,i,a)},s.alloc=o=>K().span+K().span+Z.Buffer.from(o,"utf8").length,s},zc=(r="authorized")=>q([J("staker"),J("withdrawer")],r),Kc=(r="lockup")=>q([Ne("unixTimestamp"),Ne("epoch"),J("custodian")],r),Mc=(r="voteInit")=>q([J("nodePubkey"),J("authorizedVoter"),J("authorizedWithdrawer"),se("commission")],r),Hc=(r="voteAuthorizeWithSeedArgs")=>q([K("voteAuthorizationType"),J("currentAuthorityDerivedKeyOwnerPubkey"),It("currentAuthorityDerivedKeySeed"),J("newAuthorized")],r);function ze(r){let e=0,t=0;for(;;){let n=r.shift();if(e|=(n&127)<<t*7,t+=1,!(n&128))break}return e}function Ke(r,e){let t=e;for(;;){let n=t&127;if(t>>=7,t==0){r.push(n);break}else n|=128,r.push(n)}}function be(r,e){if(!r)throw new Error(e||"Assertion failed")}class Cn{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){const n=new Map,s=i=>{const a=i.toBase58();let c=n.get(a);return c===void 0&&(c={isSigner:!1,isWritable:!1,isInvoked:!1},n.set(a,c)),c},o=s(t);o.isSigner=!0,o.isWritable=!0;for(const i of e){s(i.programId).isInvoked=!0;for(const a of i.keys){const c=s(a.pubkey);c.isSigner||(c.isSigner=a.isSigner),c.isWritable||(c.isWritable=a.isWritable)}}return new Cn(t,n)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];be(e.length<=256,"Max static account keys length exceeded");const t=e.filter(([,c])=>c.isSigner&&c.isWritable),n=e.filter(([,c])=>c.isSigner&&!c.isWritable),s=e.filter(([,c])=>!c.isSigner&&c.isWritable),o=e.filter(([,c])=>!c.isSigner&&!c.isWritable),i={numRequiredSignatures:t.length+n.length,numReadonlySignedAccounts:n.length,numReadonlyUnsignedAccounts:o.length};{be(t.length>0,"Expected at least one writable signer key");const[c]=t[0];be(c===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const a=[...t.map(([c])=>new M(c)),...n.map(([c])=>new M(c)),...s.map(([c])=>new M(c)),...o.map(([c])=>new M(c))];return[i,a]}extractTableLookup(e){const[t,n]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&i.isWritable),[s,o]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&!i.isWritable);if(!(t.length===0&&s.length===0))return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:s},{writable:n,readonly:o}]}drainKeysFoundInLookupTable(e,t){const n=new Array,s=new Array;for(const[o,i]of this.keyMetaMap.entries())if(t(i)){const a=new M(o),c=e.findIndex(u=>u.equals(a));c>=0&&(be(c<256,"Max lookup table index exceeded"),n.push(c),s.push(a),this.keyMetaMap.delete(o))}return[n,s]}}class lt{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(t=>new M(t)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(t=>this.indexToProgramIds.set(t.programIdIndex,this.accountKeys[t.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:Ae.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new bn(this.staticAccountKeys)}static compile(e){const t=Cn.compile(e.instructions,e.payerKey),[n,s]=t.getMessageComponents(),i=new bn(s).compileInstructions(e.instructions).map(a=>({programIdIndex:a.programIdIndex,accounts:a.accountKeyIndexes,data:Ae.encode(a.data)}));return new lt({header:n,accountKeys:s,recentBlockhash:e.recentBlockhash,instructions:i})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){const n=e-t,o=this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts;return n<o}else{const n=t-this.header.numReadonlySignedAccounts;return e<n}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,t)=>!this.isProgramId(t))}serialize(){const e=this.accountKeys.length;let t=[];Ke(t,e);const n=this.instructions.map(y=>{const{accounts:_,programIdIndex:p}=y,g=Array.from(Ae.decode(y.data));let d=[];Ke(d,_.length);let f=[];return Ke(f,g.length),{programIdIndex:p,keyIndicesCount:Z.Buffer.from(d),keyIndices:_,dataLength:Z.Buffer.from(f),data:g}});let s=[];Ke(s,n.length);let o=Z.Buffer.alloc(Tt);Z.Buffer.from(s).copy(o);let i=s.length;n.forEach(y=>{const p=q([se("programIdIndex"),ge(y.keyIndicesCount.length,"keyIndicesCount"),Ce(se("keyIndex"),y.keyIndices.length,"keyIndices"),ge(y.dataLength.length,"dataLength"),Ce(se("userdatum"),y.data.length,"data")]).encode(y,o,i);i+=p}),o=o.slice(0,i);const a=q([ge(1,"numRequiredSignatures"),ge(1,"numReadonlySignedAccounts"),ge(1,"numReadonlyUnsignedAccounts"),ge(t.length,"keyCount"),Ce(J("key"),e,"keys"),J("recentBlockhash")]),c={numRequiredSignatures:Z.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:Z.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:Z.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:Z.Buffer.from(t),keys:this.accountKeys.map(y=>Lt(y.toBytes())),recentBlockhash:Ae.decode(this.recentBlockhash)};let u=Z.Buffer.alloc(2048);const l=a.encode(c,u);return o.copy(u,l),u.slice(0,l+o.length)}static from(e){let t=[...e];const n=t.shift();if(n!==(n&Ao))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const s=t.shift(),o=t.shift(),i=ze(t);let a=[];for(let _=0;_<i;_++){const p=t.slice(0,Ze);t=t.slice(Ze),a.push(new M(Z.Buffer.from(p)))}const c=t.slice(0,Ze);t=t.slice(Ze);const u=ze(t);let l=[];for(let _=0;_<u;_++){const p=t.shift(),g=ze(t),d=t.slice(0,g);t=t.slice(g);const f=ze(t),m=t.slice(0,f),v=Ae.encode(Z.Buffer.from(m));t=t.slice(f),l.push({programIdIndex:p,accounts:d,data:v})}const y={header:{numRequiredSignatures:n,numReadonlySignedAccounts:s,numReadonlyUnsignedAccounts:o},recentBlockhash:Ae.encode(Z.Buffer.from(c)),accountKeys:a,instructions:l};return new lt(y)}}class vn{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(const t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new bn(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures,n=this.staticAccountKeys.length;if(e>=n){const s=e-n,o=this.addressTableLookups.reduce((i,a)=>i+a.writableIndexes.length,0);return s<o}else if(e>=this.header.numRequiredSignatures){const s=e-t,i=n-t-this.header.numReadonlyUnsignedAccounts;return s<i}else{const s=t-this.header.numReadonlySignedAccounts;return e<s}}resolveAddressTableLookups(e){const t={writable:[],readonly:[]};for(const n of this.addressTableLookups){const s=e.find(o=>o.key.equals(n.accountKey));if(!s)throw new Error(`Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`);for(const o of n.writableIndexes)if(o<s.state.addresses.length)t.writable.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${n.accountKey.toBase58()}`);for(const o of n.readonlyIndexes)if(o<s.state.addresses.length)t.readonly.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${n.accountKey.toBase58()}`)}return t}static compile(e){const t=Cn.compile(e.instructions,e.payerKey),n=new Array,s={writable:new Array,readonly:new Array},o=e.addressLookupTableAccounts||[];for(const l of o){const y=t.extractTableLookup(l);if(y!==void 0){const[_,{writable:p,readonly:g}]=y;n.push(_),s.writable.push(...p),s.readonly.push(...g)}}const[i,a]=t.getMessageComponents(),u=new bn(a,s).compileInstructions(e.instructions);return new vn({header:i,staticAccountKeys:a,recentBlockhash:e.recentBlockhash,compiledInstructions:u,addressTableLookups:n})}serialize(){const e=Array();Ke(e,this.staticAccountKeys.length);const t=this.serializeInstructions(),n=Array();Ke(n,this.compiledInstructions.length);const s=this.serializeAddressTableLookups(),o=Array();Ke(o,this.addressTableLookups.length);const i=q([se("prefix"),q([se("numRequiredSignatures"),se("numReadonlySignedAccounts"),se("numReadonlyUnsignedAccounts")],"header"),ge(e.length,"staticAccountKeysLength"),Ce(J(),this.staticAccountKeys.length,"staticAccountKeys"),J("recentBlockhash"),ge(n.length,"instructionsLength"),ge(t.length,"serializedInstructions"),ge(o.length,"addressTableLookupsLength"),ge(s.length,"serializedAddressTableLookups")]),a=new Uint8Array(Tt),c=1<<7,u=i.encode({prefix:c,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map(l=>l.toBytes()),recentBlockhash:Ae.decode(this.recentBlockhash),instructionsLength:new Uint8Array(n),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(o),serializedAddressTableLookups:s},a);return a.slice(0,u)}serializeInstructions(){let e=0;const t=new Uint8Array(Tt);for(const n of this.compiledInstructions){const s=Array();Ke(s,n.accountKeyIndexes.length);const o=Array();Ke(o,n.data.length);const i=q([se("programIdIndex"),ge(s.length,"encodedAccountKeyIndexesLength"),Ce(se(),n.accountKeyIndexes.length,"accountKeyIndexes"),ge(o.length,"encodedDataLength"),ge(n.data.length,"data")]);e+=i.encode({programIdIndex:n.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(s),accountKeyIndexes:n.accountKeyIndexes,encodedDataLength:new Uint8Array(o),data:n.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0;const t=new Uint8Array(Tt);for(const n of this.addressTableLookups){const s=Array();Ke(s,n.writableIndexes.length);const o=Array();Ke(o,n.readonlyIndexes.length);const i=q([J("accountKey"),ge(s.length,"encodedWritableIndexesLength"),Ce(se(),n.writableIndexes.length,"writableIndexes"),ge(o.length,"encodedReadonlyIndexesLength"),Ce(se(),n.readonlyIndexes.length,"readonlyIndexes")]);e+=i.encode({accountKey:n.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(s),writableIndexes:n.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(o),readonlyIndexes:n.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e];const n=t.shift(),s=n&Ao;be(n!==s,"Expected versioned message but received legacy message");const o=s;be(o===0,`Expected versioned message with version 0 but found version ${o}`);const i={numRequiredSignatures:t.shift(),numReadonlySignedAccounts:t.shift(),numReadonlyUnsignedAccounts:t.shift()},a=[],c=ze(t);for(let g=0;g<c;g++)a.push(new M(t.splice(0,Ze)));const u=Ae.encode(t.splice(0,Ze)),l=ze(t),y=[];for(let g=0;g<l;g++){const d=t.shift(),f=ze(t),m=t.splice(0,f),v=ze(t),h=new Uint8Array(t.splice(0,v));y.push({programIdIndex:d,accountKeyIndexes:m,data:h})}const _=ze(t),p=[];for(let g=0;g<_;g++){const d=new M(t.splice(0,Ze)),f=ze(t),m=t.splice(0,f),v=ze(t),h=t.splice(0,v);p.push({accountKey:d,writableIndexes:m,readonlyIndexes:h})}return new vn({header:i,staticAccountKeys:a,recentBlockhash:u,compiledInstructions:y,addressTableLookups:p})}}let Ge;(function(r){r[r.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",r[r.PROCESSED=1]="PROCESSED",r[r.TIMED_OUT=2]="TIMED_OUT",r[r.NONCE_INVALID=3]="NONCE_INVALID"})(Ge||(Ge={}));const $c=Z.Buffer.alloc(Jn).fill(0);class as{constructor(e){this.keys=void 0,this.programId=void 0,this.data=Z.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:t,isWritable:n})=>({pubkey:e.toJSON(),isSigner:t,isWritable:n})),programId:this.programId.toJSON(),data:[...this.data]}}}class at{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:t,nonceInfo:n}=e;this.minNonceContextSlot=t,this.nonceInfo=n}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:t,lastValidBlockHeight:n}=e;this.recentBlockhash=t,this.lastValidBlockHeight=n}else{const{recentBlockhash:t,nonceInfo:n}=e;n&&(this.nonceInfo=n),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(e.length===0)throw new Error("No instructions");return e.forEach(t=>{"instructions"in t?this.instructions=this.instructions.concat(t.instructions):"data"in t&&"programId"in t&&"keys"in t?this.instructions.push(t):this.instructions.push(new as(t))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t;if(this.nonceInfo?(e=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?t=[this.nonceInfo.nonceInstruction,...this.instructions]:t=this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");t.length<1&&console.warn("No instructions provided");let n;if(this.feePayer)n=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)n=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let d=0;d<t.length;d++)if(t[d].programId===void 0)throw new Error(`Transaction instruction index ${d} has undefined program id`);const s=[],o=[];t.forEach(d=>{d.keys.forEach(m=>{o.push({...m})});const f=d.programId.toString();s.includes(f)||s.push(f)}),s.forEach(d=>{o.push({pubkey:new M(d),isSigner:!1,isWritable:!1})});const i=[];o.forEach(d=>{const f=d.pubkey.toString(),m=i.findIndex(v=>v.pubkey.toString()===f);m>-1?(i[m].isWritable=i[m].isWritable||d.isWritable,i[m].isSigner=i[m].isSigner||d.isSigner):i.push(d)}),i.sort(function(d,f){if(d.isSigner!==f.isSigner)return d.isSigner?-1:1;if(d.isWritable!==f.isWritable)return d.isWritable?-1:1;const m={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return d.pubkey.toBase58().localeCompare(f.pubkey.toBase58(),"en",m)});const a=i.findIndex(d=>d.pubkey.equals(n));if(a>-1){const[d]=i.splice(a,1);d.isSigner=!0,d.isWritable=!0,i.unshift(d)}else i.unshift({pubkey:n,isSigner:!0,isWritable:!0});for(const d of this.signatures){const f=i.findIndex(m=>m.pubkey.equals(d.publicKey));if(f>-1)i[f].isSigner||(i[f].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${d.publicKey.toString()}`)}let c=0,u=0,l=0;const y=[],_=[];i.forEach(({pubkey:d,isSigner:f,isWritable:m})=>{f?(y.push(d.toString()),c+=1,m||(u+=1)):(_.push(d.toString()),m||(l+=1))});const p=y.concat(_),g=t.map(d=>{const{data:f,programId:m}=d;return{programIdIndex:p.indexOf(m.toString()),accounts:d.keys.map(v=>p.indexOf(v.pubkey.toString())),data:Ae.encode(f)}});return g.forEach(d=>{be(d.programIdIndex>=0),d.accounts.forEach(f=>be(f>=0))}),new lt({header:{numRequiredSignatures:c,numReadonlySignedAccounts:u,numReadonlyUnsignedAccounts:l},accountKeys:p,recentBlockhash:e,instructions:g})}_compile(){const e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);return this.signatures.length===t.length&&this.signatures.every((s,o)=>t[o].equals(s.publicKey))||(this.signatures=t.map(n=>({signature:null,publicKey:n}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(e.length===0)throw new Error("No signers");const t=new Set;this.signatures=e.filter(n=>{const s=n.toString();return t.has(s)?!1:(t.add(s),!0)}).map(n=>({signature:null,publicKey:n}))}sign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,n=[];for(const o of e){const i=o.publicKey.toString();t.has(i)||(t.add(i),n.push(o))}this.signatures=n.map(o=>({signature:null,publicKey:o.publicKey}));const s=this._compile();this._partialSign(s,...n)}partialSign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,n=[];for(const o of e){const i=o.publicKey.toString();t.has(i)||(t.add(i),n.push(o))}const s=this._compile();this._partialSign(s,...n)}_partialSign(e,...t){const n=e.serialize();t.forEach(s=>{const o=Lc(n,s.secretKey);this._addSignature(s.publicKey,Lt(o))})}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){be(t.length===64);const n=this.signatures.findIndex(s=>e.equals(s.publicKey));if(n<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[n].signature=Z.Buffer.from(t)}verifySignatures(e){return this._verifySignatures(this.serializeMessage(),e===void 0?!0:e)}_verifySignatures(e,t){for(const{signature:n,publicKey:s}of this.signatures)if(n===null){if(t)return!1}else if(!Nc(n,e,s.toBytes()))return!1;return!0}serialize(e){const{requireAllSignatures:t,verifySignatures:n}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),s=this.serializeMessage();if(n&&!this._verifySignatures(s,t))throw new Error("Signature verification failed");return this._serialize(s)}_serialize(e){const{signatures:t}=this,n=[];Ke(n,t.length);const s=n.length+t.length*64+e.length,o=Z.Buffer.alloc(s);return be(t.length<256),Z.Buffer.from(n).copy(o,0),t.forEach(({signature:i},a)=>{i!==null&&(be(i.length===64,"signature has invalid length"),Z.Buffer.from(i).copy(o,n.length+a*64))}),e.copy(o,n.length+t.length*64),be(o.length<=Tt,`Transaction too large: ${o.length} > ${Tt}`),o}get keys(){return be(this.instructions.length===1),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return be(this.instructions.length===1),this.instructions[0].programId}get data(){return be(this.instructions.length===1),this.instructions[0].data}static from(e){let t=[...e];const n=ze(t);let s=[];for(let o=0;o<n;o++){const i=t.slice(0,Jn);t=t.slice(Jn),s.push(Ae.encode(Z.Buffer.from(i)))}return at.populate(lt.from(t),s)}static populate(e,t=[]){const n=new at;return n.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(n.feePayer=e.accountKeys[0]),t.forEach((s,o)=>{const i={signature:s==Ae.encode($c)?null:Ae.decode(s),publicKey:e.accountKeys[o]};n.signatures.push(i)}),e.instructions.forEach(s=>{const o=s.accounts.map(i=>{const a=e.accountKeys[i];return{pubkey:a,isSigner:n.signatures.some(c=>c.publicKey.toString()===a.toString())||e.isAccountSigner(i),isWritable:e.isAccountWritable(i)}});n.instructions.push(new as({keys:o,programId:e.accountKeys[s.programIdIndex],data:Ae.decode(s.data)}))}),n._message=e,n._json=n.toJSON(),n}}const Dc=160,jc=64,Wc=Dc/jc,Gc=1e3/Wc;new M("SysvarC1ock11111111111111111111111111111111");new M("SysvarEpochSchedu1e111111111111111111111111");new M("Sysvar1nstructions1111111111111111111111111");new M("SysvarRecentB1ockHashes11111111111111111111");new M("SysvarRent111111111111111111111111111111111");new M("SysvarRewards111111111111111111111111111111");new M("SysvarS1otHashes111111111111111111111111111");new M("SysvarS1otHistory11111111111111111111111111");new M("SysvarStakeHistory1111111111111111111111111");function At(r){return new Promise(e=>setTimeout(e,r))}const Vc=ke("lamportsPerSignature"),Co=q([K("version"),K("state"),J("authorizedPubkey"),J("nonce"),q([Vc],"feeCalculator")]);Co.span;class Ir{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){const t=Co.decode(Lt(e),0);return new Ir({authorizedPubkey:new M(t.authorizedPubkey),nonce:new M(t.nonce).toString(),feeCalculator:t.feeCalculator})}}const Zc=r=>{const e=r.decode.bind(r),t=r.encode.bind(r);return{decode:e,encode:t}},Yc=r=>e=>{const t=ge(r,e),{encode:n,decode:s}=Zc(t),o=t;return o.decode=(i,a)=>{const c=s(i,a);return Wa(Z.Buffer.from(c))},o.encode=(i,a,c)=>{const u=Za(i,r);return n(u,a,c)},o},Nt=Yc(8);Object.freeze({Create:{index:0,layout:q([K("instruction"),Ne("lamports"),Ne("space"),J("programId")])},Assign:{index:1,layout:q([K("instruction"),J("programId")])},Transfer:{index:2,layout:q([K("instruction"),Nt("lamports")])},CreateWithSeed:{index:3,layout:q([K("instruction"),J("base"),It("seed"),Ne("lamports"),Ne("space"),J("programId")])},AdvanceNonceAccount:{index:4,layout:q([K("instruction")])},WithdrawNonceAccount:{index:5,layout:q([K("instruction"),Ne("lamports")])},InitializeNonceAccount:{index:6,layout:q([K("instruction"),J("authorized")])},AuthorizeNonceAccount:{index:7,layout:q([K("instruction"),J("authorized")])},Allocate:{index:8,layout:q([K("instruction"),Ne("space")])},AllocateWithSeed:{index:9,layout:q([K("instruction"),J("base"),It("seed"),Ne("space"),J("programId")])},AssignWithSeed:{index:10,layout:q([K("instruction"),J("base"),It("seed"),J("programId")])},TransferWithSeed:{index:11,layout:q([K("instruction"),Nt("lamports"),It("seed"),J("programId")])},UpgradeNonceAccount:{index:12,layout:q([K("instruction")])}});new M("11111111111111111111111111111111");new M("BPFLoader2111111111111111111111111111111111");var Xc=Object.prototype.toString,Jc=Object.keys||function(r){var e=[];for(var t in r)e.push(t);return e};function Wt(r,e){var t,n,s,o,i,a,c;if(r===!0)return"true";if(r===!1)return"false";switch(typeof r){case"object":if(r===null)return null;if(r.toJSON&&typeof r.toJSON=="function")return Wt(r.toJSON(),e);if(c=Xc.call(r),c==="[object Array]"){for(s="[",n=r.length-1,t=0;t<n;t++)s+=Wt(r[t],!0)+",";return n>-1&&(s+=Wt(r[t],!0)),s+"]"}else if(c==="[object Object]"){for(o=Jc(r).sort(),n=o.length,s="",t=0;t<n;)i=o[t],a=Wt(r[i],!1),a!==void 0&&(s&&(s+=","),s+=JSON.stringify(i)+":"+a),t++;return"{"+s+"}"}else return JSON.stringify(r);case"function":case"undefined":return e?null:void 0;case"string":return JSON.stringify(r);default:return isFinite(r)?r:null}}var Qc=function(r){var e=Wt(r,!1);if(e!==void 0)return""+e},cs=Qc;const Dt=32;function Kn(r){let e=0;for(;r>1;)r/=2,e++;return e}function eu(r){return r===0?1:(r--,r|=r>>1,r|=r>>2,r|=r>>4,r|=r>>8,r|=r>>16,r|=r>>32,r+1)}class tu{constructor(e,t,n,s,o){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=t,this.warmup=n,this.firstNormalEpoch=s,this.firstNormalSlot=o}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){const t=Kn(eu(e+Dt+1))-Kn(Dt)-1,n=this.getSlotsInEpoch(t),s=e-(n-Dt);return[t,s]}else{const t=e-this.firstNormalSlot,n=Math.floor(t/this.slotsPerEpoch),s=this.firstNormalEpoch+n,o=t%this.slotsPerEpoch;return[s,o]}}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?(Math.pow(2,e)-1)*Dt:(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+Kn(Dt)):this.slotsPerEpoch}}class us extends Error{constructor(e,t){super(e),this.logs=void 0,this.logs=t}}class F extends Error{constructor({code:e,message:t,data:n},s){super(s!=null?`${s}: ${t}`:t),this.code=void 0,this.data=void 0,this.code=e,this.data=n,this.name="SolanaJSONRPCError"}}var nu=globalThis.fetch;class ru extends pc{constructor(e,t,n){const s=o=>{const i=gc(o,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...t});return"socket"in i?this.underlyingSocket=i.socket:this.underlyingSocket=i,i};super(s,e,t,n),this.underlyingSocket=void 0}call(...e){var n;const t=(n=this.underlyingSocket)==null?void 0:n.readyState;return t===1?super.call(...e):Promise.reject(new Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}notify(...e){var n;const t=(n=this.underlyingSocket)==null?void 0:n.readyState;return t===1?super.notify(...e):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}}function su(r,e){let t;try{t=r.layout.decode(e)}catch(n){throw new Error("invalid instruction; "+n)}if(t.typeIndex!==r.index)throw new Error(`invalid account data; account type mismatch ${t.typeIndex} != ${r.index}`);return t}const ls=56;class ds{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){const e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){const t=su(ou,e),n=e.length-ls;be(n>=0,"lookup table is invalid"),be(n%32===0,"lookup table is invalid");const s=n/32,{addresses:o}=q([Ce(J(),s,"addresses")]).decode(e.slice(ls));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:t.authority.length!==0?new M(t.authority[0]):void 0,addresses:o.map(i=>new M(i))}}}const ou={index:1,layout:q([K("typeIndex"),Nt("deactivationSlot"),ke("lastExtendedSlot"),se("lastExtendedStartIndex"),se(),Ce(J(),bt(se(),-1),"authority")])},iu=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function au(r){const e=r.match(iu);if(e==null)throw TypeError(`Failed to validate endpoint URL \`${r}\``);const[t,n,s,o]=e,i=r.startsWith("https:")?"wss:":"ws:",a=s==null?null:parseInt(s.slice(1),10),c=a==null?"":`:${a+1}`;return`${i}//${n}${c}${o}`}const Se=nn(kr(M),R(),r=>new M(r)),To=Br([R(),de("base64")]),Rr=nn(kr(Z.Buffer),To,r=>Z.Buffer.from(r[0],"base64")),cu=30*1e3;function uu(r){if(/^https?:/.test(r)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return r}function le(r){let e,t;if(typeof r=="string")e=r;else if(r){const{commitment:n,...s}=r;e=n,t=s}return{commitment:e,config:t}}function Oo(r){return Pe([I({jsonrpc:de("2.0"),id:R(),result:r}),I({jsonrpc:de("2.0"),id:R(),error:I({code:tn(),message:R(),data:H(rc())})})])}const lu=Oo(tn());function V(r){return nn(Oo(r),lu,e=>"error"in e?e:{...e,result:T(e.result,r)})}function me(r){return V(I({context:I({slot:b()}),value:r}))}function Tn(r){return I({context:I({slot:b()}),value:r})}function Mn(r,e){return r===0?new vn({header:e.header,staticAccountKeys:e.accountKeys.map(t=>new M(t)),recentBlockhash:e.recentBlockhash,compiledInstructions:e.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:Ae.decode(t.data)})),addressTableLookups:e.addressTableLookups}):new lt(e)}const du=I({foundation:b(),foundationTerm:b(),initial:b(),taper:b(),terminal:b()}),fu=V(P(L(I({epoch:b(),effectiveSlot:b(),amount:b(),postBalance:b(),commission:H(L(b()))})))),hu=P(I({slot:b(),prioritizationFee:b()})),pu=I({total:b(),validator:b(),foundation:b(),epoch:b()}),gu=I({epoch:b(),slotIndex:b(),slotsInEpoch:b(),absoluteSlot:b(),blockHeight:H(b()),transactionCount:H(b())}),yu=I({slotsPerEpoch:b(),leaderScheduleSlotOffset:b(),warmup:st(),firstNormalEpoch:b(),firstNormalSlot:b()}),mu=ao(R(),P(b())),_t=L(Pe([I({}),R()])),wu=I({err:_t}),bu=de("receivedSignature"),vu=I({"solana-core":R(),"feature-set":H(b())}),fs=me(I({err:L(Pe([I({}),R()])),logs:L(P(R())),accounts:H(L(P(L(I({executable:st(),owner:R(),lamports:b(),data:P(R()),rentEpoch:H(b())}))))),unitsConsumed:H(b()),returnData:H(L(I({programId:R(),data:Br([R(),de("base64")])})))})),Su=me(I({byIdentity:ao(R(),P(b())),range:I({firstSlot:b(),lastSlot:b()})}));function xu(r,e,t,n,s,o){const i=t||nu;let a;o!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let c;return n&&(c=async(l,y)=>{const _=await new Promise((p,g)=>{try{n(l,y,(d,f)=>p([d,f]))}catch(d){g(d)}});return await i(..._)}),new dc(async(l,y)=>{const _={method:"POST",body:l,agent:a,headers:Object.assign({"Content-Type":"application/json"},e||{},xl)};try{let p=5,g,d=500;for(;c?g=await c(r,_):g=await i(r,_),!(g.status!==429||s===!0||(p-=1,p===0));)console.log(`Server responded with ${g.status} ${g.statusText}.  Retrying after ${d}ms delay...`),await At(d),d*=2;const f=await g.text();g.ok?y(null,f):y(new Error(`${g.status} ${g.statusText}: ${f}`))}catch(p){p instanceof Error&&y(p)}},{})}function Eu(r){return(e,t)=>new Promise((n,s)=>{r.request(e,t,(o,i)=>{if(o){s(o);return}n(i)})})}function _u(r){return e=>new Promise((t,n)=>{e.length===0&&t([]);const s=e.map(o=>r.request(o.methodName,o.args));r.request(s,(o,i)=>{if(o){n(o);return}t(i)})})}const ku=V(du),Bu=V(pu),Au=V(hu),Iu=V(gu),Ru=V(yu),Cu=V(mu),Tu=V(b()),Ou=me(I({total:b(),circulating:b(),nonCirculating:b(),nonCirculatingAccounts:P(Se)})),Qn=I({amount:R(),uiAmount:L(b()),decimals:b(),uiAmountString:H(R())}),Pu=me(P(I({address:Se,amount:R(),uiAmount:L(b()),decimals:b(),uiAmountString:H(R())}))),Lu=me(P(I({pubkey:Se,account:I({executable:st(),owner:Se,lamports:b(),data:Rr,rentEpoch:b()})}))),er=I({program:R(),parsed:tn(),space:b()}),Nu=me(P(I({pubkey:Se,account:I({executable:st(),owner:Se,lamports:b(),data:er,rentEpoch:b()})}))),Uu=me(P(I({lamports:b(),address:Se}))),Zt=I({executable:st(),owner:Se,lamports:b(),data:Rr,rentEpoch:b()}),qu=I({pubkey:Se,account:Zt}),Fu=nn(Pe([kr(Z.Buffer),er]),Pe([To,er]),r=>Array.isArray(r)?T(r,Rr):r),tr=I({executable:st(),owner:Se,lamports:b(),data:Fu,rentEpoch:b()}),zu=I({pubkey:Se,account:tr}),Ku=I({state:Pe([de("active"),de("inactive"),de("activating"),de("deactivating")]),active:b(),inactive:b()}),Mu=V(P(I({signature:R(),slot:b(),err:_t,memo:L(R()),blockTime:H(L(b()))}))),Hu=V(P(I({signature:R(),slot:b(),err:_t,memo:L(R()),blockTime:H(L(b()))}))),$u=I({subscription:b(),result:Tn(Zt)}),Du=I({pubkey:Se,account:Zt}),ju=I({subscription:b(),result:Tn(Du)}),Wu=I({parent:b(),slot:b(),root:b()}),Gu=I({subscription:b(),result:Wu}),Vu=Pe([I({type:Pe([de("firstShredReceived"),de("completed"),de("optimisticConfirmation"),de("root")]),slot:b(),timestamp:b()}),I({type:de("createdBank"),parent:b(),slot:b(),timestamp:b()}),I({type:de("frozen"),slot:b(),timestamp:b(),stats:I({numTransactionEntries:b(),numSuccessfulTransactions:b(),numFailedTransactions:b(),maxTransactionsPerEntry:b()})}),I({type:de("dead"),slot:b(),timestamp:b(),err:R()})]),Zu=I({subscription:b(),result:Vu}),Yu=I({subscription:b(),result:Tn(Pe([wu,bu]))}),Xu=I({subscription:b(),result:b()}),Ju=I({pubkey:R(),gossip:L(R()),tpu:L(R()),rpc:L(R()),version:L(R())}),hs=I({votePubkey:R(),nodePubkey:R(),activatedStake:b(),epochVoteAccount:st(),epochCredits:P(Br([b(),b(),b()])),commission:b(),lastVote:b(),rootSlot:L(b())}),Qu=V(I({current:P(hs),delinquent:P(hs)})),el=Pe([de("processed"),de("confirmed"),de("finalized")]),tl=I({slot:b(),confirmations:L(b()),err:_t,confirmationStatus:H(el)}),nl=me(P(L(tl))),rl=V(b()),Po=I({accountKey:Se,writableIndexes:P(b()),readonlyIndexes:P(b())}),Cr=I({signatures:P(R()),message:I({accountKeys:P(R()),header:I({numRequiredSignatures:b(),numReadonlySignedAccounts:b(),numReadonlyUnsignedAccounts:b()}),instructions:P(I({accounts:P(b()),data:R(),programIdIndex:b()})),recentBlockhash:R(),addressTableLookups:H(P(Po))})}),Lo=I({pubkey:Se,signer:st(),writable:st(),source:H(Pe([de("transaction"),de("lookupTable")]))}),No=I({accountKeys:P(Lo),signatures:P(R())}),Uo=I({parsed:tn(),program:R(),programId:Se}),qo=I({accounts:P(Se),data:R(),programId:Se}),sl=Pe([qo,Uo]),ol=Pe([I({parsed:tn(),program:R(),programId:R()}),I({accounts:P(R()),data:R(),programId:R()})]),Fo=nn(sl,ol,r=>"accounts"in r?T(r,qo):T(r,Uo)),zo=I({signatures:P(R()),message:I({accountKeys:P(Lo),instructions:P(Fo),recentBlockhash:R(),addressTableLookups:H(L(P(Po)))})}),Sn=I({accountIndex:b(),mint:R(),owner:H(R()),uiTokenAmount:Qn}),Ko=I({writable:P(Se),readonly:P(Se)}),On=I({err:_t,fee:b(),innerInstructions:H(L(P(I({index:b(),instructions:P(I({accounts:P(b()),data:R(),programIdIndex:b()}))})))),preBalances:P(b()),postBalances:P(b()),logMessages:H(L(P(R()))),preTokenBalances:H(L(P(Sn))),postTokenBalances:H(L(P(Sn))),loadedAddresses:H(Ko),computeUnitsConsumed:H(b())}),Tr=I({err:_t,fee:b(),innerInstructions:H(L(P(I({index:b(),instructions:P(Fo)})))),preBalances:P(b()),postBalances:P(b()),logMessages:H(L(P(R()))),preTokenBalances:H(L(P(Sn))),postTokenBalances:H(L(P(Sn))),loadedAddresses:H(Ko),computeUnitsConsumed:H(b())}),Mt=Pe([de(0),de("legacy")]),kt=I({pubkey:R(),lamports:b(),postBalance:L(b()),rewardType:L(R()),commission:H(L(b()))}),il=V(L(I({blockhash:R(),previousBlockhash:R(),parentSlot:b(),transactions:P(I({transaction:Cr,meta:L(On),version:H(Mt)})),rewards:H(P(kt)),blockTime:L(b()),blockHeight:L(b())}))),al=V(L(I({blockhash:R(),previousBlockhash:R(),parentSlot:b(),rewards:H(P(kt)),blockTime:L(b()),blockHeight:L(b())}))),cl=V(L(I({blockhash:R(),previousBlockhash:R(),parentSlot:b(),transactions:P(I({transaction:No,meta:L(On),version:H(Mt)})),rewards:H(P(kt)),blockTime:L(b()),blockHeight:L(b())}))),ul=V(L(I({blockhash:R(),previousBlockhash:R(),parentSlot:b(),transactions:P(I({transaction:zo,meta:L(Tr),version:H(Mt)})),rewards:H(P(kt)),blockTime:L(b()),blockHeight:L(b())}))),ll=V(L(I({blockhash:R(),previousBlockhash:R(),parentSlot:b(),transactions:P(I({transaction:No,meta:L(Tr),version:H(Mt)})),rewards:H(P(kt)),blockTime:L(b()),blockHeight:L(b())}))),dl=V(L(I({blockhash:R(),previousBlockhash:R(),parentSlot:b(),rewards:H(P(kt)),blockTime:L(b()),blockHeight:L(b())}))),fl=V(L(I({blockhash:R(),previousBlockhash:R(),parentSlot:b(),transactions:P(I({transaction:Cr,meta:L(On)})),rewards:H(P(kt)),blockTime:L(b())}))),ps=V(L(I({blockhash:R(),previousBlockhash:R(),parentSlot:b(),signatures:P(R()),blockTime:L(b())}))),Hn=V(L(I({slot:b(),meta:On,blockTime:H(L(b())),transaction:Cr,version:H(Mt)}))),cn=V(L(I({slot:b(),transaction:zo,meta:L(Tr),blockTime:H(L(b())),version:H(Mt)}))),hl=me(I({blockhash:R(),feeCalculator:I({lamportsPerSignature:b()})})),pl=me(I({blockhash:R(),lastValidBlockHeight:b()})),gl=I({slot:b(),numTransactions:b(),numSlots:b(),samplePeriodSecs:b()}),yl=V(P(gl)),ml=me(L(I({feeCalculator:I({lamportsPerSignature:b()})}))),wl=V(R()),bl=V(R()),vl=I({err:_t,logs:P(R()),signature:R()}),Sl=I({result:Tn(vl),subscription:b()}),xl={"solana-client":"js/0.0.0-development"};class Or{constructor(e,t){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const u={};return async l=>{const{commitment:y,config:_}=le(l),p=this._buildArgs([],y,void 0,_),g=cs(p);return u[g]=u[g]??(async()=>{try{const d=await this._rpcRequest("getBlockHeight",p),f=T(d,V(b()));if("error"in f)throw new F(f.error,"failed to get block height information");return f.result}finally{delete u[g]}})(),await u[g]}})();let n,s,o,i,a,c;t&&typeof t=="string"?this._commitment=t:t&&(this._commitment=t.commitment,this._confirmTransactionInitialTimeout=t.confirmTransactionInitialTimeout,n=t.wsEndpoint,s=t.httpHeaders,o=t.fetch,i=t.fetchMiddleware,a=t.disableRetryOnRateLimit,c=t.httpAgent),this._rpcEndpoint=uu(e),this._rpcWsEndpoint=n||au(e),this._rpcClient=xu(e,s,o,i,a,c),this._rpcRequest=Eu(this._rpcClient),this._rpcBatchRequest=_u(this._rpcClient),this._rpcWebSocket=new ru(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(e,t){const{commitment:n,config:s}=le(t),o=this._buildArgs([e.toBase58()],n,void 0,s),i=await this._rpcRequest("getBalance",o),a=T(i,me(b()));if("error"in a)throw new F(a.error,`failed to get balance for ${e.toBase58()}`);return a.result}async getBalance(e,t){return await this.getBalanceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+n)})}async getBlockTime(e){const t=await this._rpcRequest("getBlockTime",[e]),n=T(t,V(L(b())));if("error"in n)throw new F(n.error,`failed to get block time for slot ${e}`);return n.result}async getMinimumLedgerSlot(){const e=await this._rpcRequest("minimumLedgerSlot",[]),t=T(e,V(b()));if("error"in t)throw new F(t.error,"failed to get minimum ledger slot");return t.result}async getFirstAvailableBlock(){const e=await this._rpcRequest("getFirstAvailableBlock",[]),t=T(e,Tu);if("error"in t)throw new F(t.error,"failed to get first available block");return t.result}async getSupply(e){let t={};typeof e=="string"?t={commitment:e}:e?t={...e,commitment:e&&e.commitment||this.commitment}:t={commitment:this.commitment};const n=await this._rpcRequest("getSupply",[t]),s=T(n,Ou);if("error"in s)throw new F(s.error,"failed to get supply");return s.result}async getTokenSupply(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenSupply",n),o=T(s,me(Qn));if("error"in o)throw new F(o.error,"failed to get token supply");return o.result}async getTokenAccountBalance(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenAccountBalance",n),o=T(s,me(Qn));if("error"in o)throw new F(o.error,"failed to get token account balance");return o.result}async getTokenAccountsByOwner(e,t,n){const{commitment:s,config:o}=le(n);let i=[e.toBase58()];"mint"in t?i.push({mint:t.mint.toBase58()}):i.push({programId:t.programId.toBase58()});const a=this._buildArgs(i,s,"base64",o),c=await this._rpcRequest("getTokenAccountsByOwner",a),u=T(c,Lu);if("error"in u)throw new F(u.error,`failed to get token accounts owned by account ${e.toBase58()}`);return u.result}async getParsedTokenAccountsByOwner(e,t,n){let s=[e.toBase58()];"mint"in t?s.push({mint:t.mint.toBase58()}):s.push({programId:t.programId.toBase58()});const o=this._buildArgs(s,n,"jsonParsed"),i=await this._rpcRequest("getTokenAccountsByOwner",o),a=T(i,Nu);if("error"in a)throw new F(a.error,`failed to get token accounts owned by account ${e.toBase58()}`);return a.result}async getLargestAccounts(e){const t={...e,commitment:e&&e.commitment||this.commitment},n=t.filter||t.commitment?[t]:[],s=await this._rpcRequest("getLargestAccounts",n),o=T(s,Uu);if("error"in o)throw new F(o.error,"failed to get largest accounts");return o.result}async getTokenLargestAccounts(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenLargestAccounts",n),o=T(s,Pu);if("error"in o)throw new F(o.error,"failed to get token largest accounts");return o.result}async getAccountInfoAndContext(e,t){const{commitment:n,config:s}=le(t),o=this._buildArgs([e.toBase58()],n,"base64",s),i=await this._rpcRequest("getAccountInfo",o),a=T(i,me(L(Zt)));if("error"in a)throw new F(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getParsedAccountInfo(e,t){const{commitment:n,config:s}=le(t),o=this._buildArgs([e.toBase58()],n,"jsonParsed",s),i=await this._rpcRequest("getAccountInfo",o),a=T(i,me(L(tr)));if("error"in a)throw new F(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getAccountInfo(e,t){try{return(await this.getAccountInfoAndContext(e,t)).value}catch(n){throw new Error("failed to get info about account "+e.toBase58()+": "+n)}}async getMultipleParsedAccounts(e,t){const{commitment:n,config:s}=le(t),o=e.map(u=>u.toBase58()),i=this._buildArgs([o],n,"jsonParsed",s),a=await this._rpcRequest("getMultipleAccounts",i),c=T(a,me(P(L(tr))));if("error"in c)throw new F(c.error,`failed to get info for accounts ${o}`);return c.result}async getMultipleAccountsInfoAndContext(e,t){const{commitment:n,config:s}=le(t),o=e.map(u=>u.toBase58()),i=this._buildArgs([o],n,"base64",s),a=await this._rpcRequest("getMultipleAccounts",i),c=T(a,me(P(L(Zt))));if("error"in c)throw new F(c.error,`failed to get info for accounts ${o}`);return c.result}async getMultipleAccountsInfo(e,t){return(await this.getMultipleAccountsInfoAndContext(e,t)).value}async getStakeActivation(e,t,n){const{commitment:s,config:o}=le(t),i=this._buildArgs([e.toBase58()],s,void 0,{...o,epoch:n??(o==null?void 0:o.epoch)}),a=await this._rpcRequest("getStakeActivation",i),c=T(a,V(Ku));if("error"in c)throw new F(c.error,`failed to get Stake Activation ${e.toBase58()}`);return c.result}async getProgramAccounts(e,t){const{commitment:n,config:s}=le(t),{encoding:o,...i}=s||{},a=this._buildArgs([e.toBase58()],n,o||"base64",i),c=await this._rpcRequest("getProgramAccounts",a),u=P(qu),l=i.withContext===!0?T(c,me(u)):T(c,V(u));if("error"in l)throw new F(l.error,`failed to get accounts owned by program ${e.toBase58()}`);return l.result}async getParsedProgramAccounts(e,t){const{commitment:n,config:s}=le(t),o=this._buildArgs([e.toBase58()],n,"jsonParsed",s),i=await this._rpcRequest("getProgramAccounts",o),a=T(i,V(P(zu)));if("error"in a)throw new F(a.error,`failed to get accounts owned by program ${e.toBase58()}`);return a.result}async confirmTransaction(e,t){var o;let n;if(typeof e=="string")n=e;else{const i=e;if((o=i.abortSignal)!=null&&o.aborted)return Promise.reject(i.abortSignal.reason);n=i.signature}let s;try{s=Ae.decode(n)}catch{throw new Error("signature must be base58 encoded: "+n)}return be(s.length===64,"signature has invalid length"),typeof e=="string"?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:t||this.commitment,signature:n}):"lastValidBlockHeight"in e?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t||this.commitment,strategy:e}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:t||this.commitment,strategy:e})}getCancellationPromise(e){return new Promise((t,n)=>{e!=null&&(e.aborted?n(e.reason):e.addEventListener("abort",()=>{n(e.reason)}))})}getTransactionConfirmationPromise({commitment:e,signature:t}){let n,s,o=!1;const i=new Promise((c,u)=>{try{n=this.onSignature(t,(y,_)=>{n=void 0;const p={context:_,value:y};c({__type:Ge.PROCESSED,response:p})},e);const l=new Promise(y=>{n==null?y():s=this._onSubscriptionStateChange(n,_=>{_==="subscribed"&&y()})});(async()=>{if(await l,o)return;const y=await this.getSignatureStatus(t);if(o||y==null)return;const{context:_,value:p}=y;if(p!=null)if(p!=null&&p.err)u(p.err);else{switch(e){case"confirmed":case"single":case"singleGossip":{if(p.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(p.confirmationStatus==="processed"||p.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}o=!0,c({__type:Ge.PROCESSED,response:{context:_,value:p}})}})()}catch(l){u(l)}});return{abortConfirmation:()=>{s&&(s(),s=void 0),n!=null&&(this.removeSignatureListener(n),n=void 0)},confirmationPromise:i}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e,strategy:{abortSignal:t,lastValidBlockHeight:n,signature:s}}){let o=!1;const i=new Promise(y=>{const _=async()=>{try{return await this.getBlockHeight(e)}catch{return-1}};(async()=>{let p=await _();if(!o){for(;p<=n;)if(await At(1e3),o||(p=await _(),o))return;y({__type:Ge.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:a,confirmationPromise:c}=this.getTransactionConfirmationPromise({commitment:e,signature:s}),u=this.getCancellationPromise(t);let l;try{const y=await Promise.race([u,c,i]);if(y.__type===Ge.PROCESSED)l=y.response;else throw new Io(s)}finally{o=!0,a()}return l}async confirmTransactionUsingDurableNonceStrategy({commitment:e,strategy:{abortSignal:t,minContextSlot:n,nonceAccountPubkey:s,nonceValue:o,signature:i}}){let a=!1;const c=new Promise(p=>{let g=o,d=null;const f=async()=>{try{const{context:m,value:v}=await this.getNonceAndContext(s,{commitment:e,minContextSlot:n});return d=m.slot,v==null?void 0:v.nonce}catch{return g}};(async()=>{if(g=await f(),!a)for(;;){if(o!==g){p({__type:Ge.NONCE_INVALID,slotInWhichNonceDidAdvance:d});return}if(await At(2e3),a||(g=await f(),a))return}})()}),{abortConfirmation:u,confirmationPromise:l}=this.getTransactionConfirmationPromise({commitment:e,signature:i}),y=this.getCancellationPromise(t);let _;try{const p=await Promise.race([y,l,c]);if(p.__type===Ge.PROCESSED)_=p.response;else{let g;for(;;){const d=await this.getSignatureStatus(i);if(d==null)break;if(d.context.slot<(p.slotInWhichNonceDidAdvance??n)){await At(400);continue}g=d;break}if(g!=null&&g.value){const d=e||"finalized",{confirmationStatus:f}=g.value;switch(d){case"processed":case"recent":if(f!=="processed"&&f!=="confirmed"&&f!=="finalized")throw new jt(i);break;case"confirmed":case"single":case"singleGossip":if(f!=="confirmed"&&f!=="finalized")throw new jt(i);break;case"finalized":case"max":case"root":if(f!=="finalized")throw new jt(i);break;default:(m=>{})(d)}_={context:g.context,value:{err:g.value.err}}}else throw new jt(i)}}finally{a=!0,u()}return _}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:e,signature:t}){let n;const s=new Promise(c=>{let u=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{u=this._confirmTransactionInitialTimeout||3e4;break}}n=setTimeout(()=>c({__type:Ge.TIMED_OUT,timeoutMs:u}),u)}),{abortConfirmation:o,confirmationPromise:i}=this.getTransactionConfirmationPromise({commitment:e,signature:t});let a;try{const c=await Promise.race([i,s]);if(c.__type===Ge.PROCESSED)a=c.response;else throw new Ro(t,c.timeoutMs/1e3)}finally{clearTimeout(n),o()}return a}async getClusterNodes(){const e=await this._rpcRequest("getClusterNodes",[]),t=T(e,V(P(Ju)));if("error"in t)throw new F(t.error,"failed to get cluster nodes");return t.result}async getVoteAccounts(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getVoteAccounts",t),s=T(n,Qu);if("error"in s)throw new F(s.error,"failed to get vote accounts");return s.result}async getSlot(e){const{commitment:t,config:n}=le(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getSlot",s),i=T(o,V(b()));if("error"in i)throw new F(i.error,"failed to get slot");return i.result}async getSlotLeader(e){const{commitment:t,config:n}=le(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getSlotLeader",s),i=T(o,V(R()));if("error"in i)throw new F(i.error,"failed to get slot leader");return i.result}async getSlotLeaders(e,t){const n=[e,t],s=await this._rpcRequest("getSlotLeaders",n),o=T(s,V(P(Se)));if("error"in o)throw new F(o.error,"failed to get slot leaders");return o.result}async getSignatureStatus(e,t){const{context:n,value:s}=await this.getSignatureStatuses([e],t);be(s.length===1);const o=s[0];return{context:n,value:o}}async getSignatureStatuses(e,t){const n=[e];t&&n.push(t);const s=await this._rpcRequest("getSignatureStatuses",n),o=T(s,nl);if("error"in o)throw new F(o.error,"failed to get signature status");return o.result}async getTransactionCount(e){const{commitment:t,config:n}=le(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getTransactionCount",s),i=T(o,V(b()));if("error"in i)throw new F(i.error,"failed to get transaction count");return i.result}async getTotalSupply(e){return(await this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getInflationGovernor",t),s=T(n,ku);if("error"in s)throw new F(s.error,"failed to get inflation");return s.result}async getInflationReward(e,t,n){const{commitment:s,config:o}=le(n),i=this._buildArgs([e.map(u=>u.toBase58())],s,void 0,{...o,epoch:t??(o==null?void 0:o.epoch)}),a=await this._rpcRequest("getInflationReward",i),c=T(a,fu);if("error"in c)throw new F(c.error,"failed to get inflation reward");return c.result}async getInflationRate(){const e=await this._rpcRequest("getInflationRate",[]),t=T(e,Bu);if("error"in t)throw new F(t.error,"failed to get inflation rate");return t.result}async getEpochInfo(e){const{commitment:t,config:n}=le(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getEpochInfo",s),i=T(o,Iu);if("error"in i)throw new F(i.error,"failed to get epoch info");return i.result}async getEpochSchedule(){const e=await this._rpcRequest("getEpochSchedule",[]),t=T(e,Ru);if("error"in t)throw new F(t.error,"failed to get epoch schedule");const n=t.result;return new tu(n.slotsPerEpoch,n.leaderScheduleSlotOffset,n.warmup,n.firstNormalEpoch,n.firstNormalSlot)}async getLeaderSchedule(){const e=await this._rpcRequest("getLeaderSchedule",[]),t=T(e,Cu);if("error"in t)throw new F(t.error,"failed to get leader schedule");return t.result}async getMinimumBalanceForRentExemption(e,t){const n=this._buildArgs([e],t),s=await this._rpcRequest("getMinimumBalanceForRentExemption",n),o=T(s,rl);return"error"in o?(console.warn("Unable to fetch minimum balance for rent exemption"),0):o.result}async getRecentBlockhashAndContext(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getRecentBlockhash",t),s=T(n,hl);if("error"in s)throw new F(s.error,"failed to get recent blockhash");return s.result}async getRecentPerformanceSamples(e){const t=await this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),n=T(t,yl);if("error"in n)throw new F(n.error,"failed to get recent performance samples");return n.result}async getFeeCalculatorForBlockhash(e,t){const n=this._buildArgs([e],t),s=await this._rpcRequest("getFeeCalculatorForBlockhash",n),o=T(s,ml);if("error"in o)throw new F(o.error,"failed to get fee calculator");const{context:i,value:a}=o.result;return{context:i,value:a!==null?a.feeCalculator:null}}async getFeeForMessage(e,t){const n=Lt(e.serialize()).toString("base64"),s=this._buildArgs([n],t),o=await this._rpcRequest("getFeeForMessage",s),i=T(o,me(L(b())));if("error"in i)throw new F(i.error,"failed to get fee for message");if(i.result===null)throw new Error("invalid blockhash");return i.result}async getRecentPrioritizationFees(e){var i;const t=(i=e==null?void 0:e.lockedWritableAccounts)==null?void 0:i.map(a=>a.toBase58()),n=this._buildArgs(t!=null&&t.length?[t]:[]),s=await this._rpcRequest("getRecentPrioritizationFees",n),o=T(s,Au);if("error"in o)throw new F(o.error,"failed to get recent prioritization fees");return o.result}async getRecentBlockhash(e){try{return(await this.getRecentBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhash(e){try{return(await this.getLatestBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhashAndContext(e){const{commitment:t,config:n}=le(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getLatestBlockhash",s),i=T(o,pl);if("error"in i)throw new F(i.error,"failed to get latest blockhash");return i.result}async getVersion(){const e=await this._rpcRequest("getVersion",[]),t=T(e,V(vu));if("error"in t)throw new F(t.error,"failed to get version");return t.result}async getGenesisHash(){const e=await this._rpcRequest("getGenesisHash",[]),t=T(e,V(R()));if("error"in t)throw new F(t.error,"failed to get genesis hash");return t.result}async getBlock(e,t){const{commitment:n,config:s}=le(t),o=this._buildArgsAtLeastConfirmed([e],n,void 0,s),i=await this._rpcRequest("getBlock",o);try{switch(s==null?void 0:s.transactionDetails){case"accounts":{const a=T(i,cl);if("error"in a)throw a.error;return a.result}case"none":{const a=T(i,al);if("error"in a)throw a.error;return a.result}default:{const a=T(i,il);if("error"in a)throw a.error;const{result:c}=a;return c?{...c,transactions:c.transactions.map(({transaction:u,meta:l,version:y})=>({meta:l,transaction:{...u,message:Mn(y,u.message)},version:y}))}:null}}}catch(a){throw new F(a,"failed to get confirmed block")}}async getParsedBlock(e,t){const{commitment:n,config:s}=le(t),o=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",s),i=await this._rpcRequest("getBlock",o);try{switch(s==null?void 0:s.transactionDetails){case"accounts":{const a=T(i,ll);if("error"in a)throw a.error;return a.result}case"none":{const a=T(i,dl);if("error"in a)throw a.error;return a.result}default:{const a=T(i,ul);if("error"in a)throw a.error;return a.result}}}catch(a){throw new F(a,"failed to get block")}}async getBlockProduction(e){let t,n;if(typeof e=="string")n=e;else if(e){const{commitment:a,...c}=e;n=a,t=c}const s=this._buildArgs([],n,"base64",t),o=await this._rpcRequest("getBlockProduction",s),i=T(o,Su);if("error"in i)throw new F(i.error,"failed to get block production information");return i.result}async getTransaction(e,t){const{commitment:n,config:s}=le(t),o=this._buildArgsAtLeastConfirmed([e],n,void 0,s),i=await this._rpcRequest("getTransaction",o),a=T(i,Hn);if("error"in a)throw new F(a.error,"failed to get transaction");const c=a.result;return c&&{...c,transaction:{...c.transaction,message:Mn(c.version,c.transaction.message)}}}async getParsedTransaction(e,t){const{commitment:n,config:s}=le(t),o=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",s),i=await this._rpcRequest("getTransaction",o),a=T(i,cn);if("error"in a)throw new F(a.error,"failed to get transaction");return a.result}async getParsedTransactions(e,t){const{commitment:n,config:s}=le(t),o=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],n,"jsonParsed",s)}));return(await this._rpcBatchRequest(o)).map(c=>{const u=T(c,cn);if("error"in u)throw new F(u.error,"failed to get transactions");return u.result})}async getTransactions(e,t){const{commitment:n,config:s}=le(t),o=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],n,void 0,s)}));return(await this._rpcBatchRequest(o)).map(c=>{const u=T(c,Hn);if("error"in u)throw new F(u.error,"failed to get transactions");const l=u.result;return l&&{...l,transaction:{...l.transaction,message:Mn(l.version,l.transaction.message)}}})}async getConfirmedBlock(e,t){const n=this._buildArgsAtLeastConfirmed([e],t),s=await this._rpcRequest("getConfirmedBlock",n),o=T(s,fl);if("error"in o)throw new F(o.error,"failed to get confirmed block");const i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");const a={...i,transactions:i.transactions.map(({transaction:c,meta:u})=>{const l=new lt(c.message);return{meta:u,transaction:{...c,message:l}}})};return{...a,transactions:a.transactions.map(({transaction:c,meta:u})=>({meta:u,transaction:at.populate(c.message,c.signatures)}))}}async getBlocks(e,t,n){const s=this._buildArgsAtLeastConfirmed(t!==void 0?[e,t]:[e],n),o=await this._rpcRequest("getBlocks",s),i=T(o,V(P(b())));if("error"in i)throw new F(i.error,"failed to get blocks");return i.result}async getBlockSignatures(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getBlock",n),o=T(s,ps);if("error"in o)throw new F(o.error,"failed to get block");const i=o.result;if(!i)throw new Error("Block "+e+" not found");return i}async getConfirmedBlockSignatures(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getConfirmedBlock",n),o=T(s,ps);if("error"in o)throw new F(o.error,"failed to get confirmed block");const i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");return i}async getConfirmedTransaction(e,t){const n=this._buildArgsAtLeastConfirmed([e],t),s=await this._rpcRequest("getConfirmedTransaction",n),o=T(s,Hn);if("error"in o)throw new F(o.error,"failed to get transaction");const i=o.result;if(!i)return i;const a=new lt(i.transaction.message),c=i.transaction.signatures;return{...i,transaction:at.populate(a,c)}}async getParsedConfirmedTransaction(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),s=await this._rpcRequest("getConfirmedTransaction",n),o=T(s,cn);if("error"in o)throw new F(o.error,"failed to get confirmed transaction");return o.result}async getParsedConfirmedTransactions(e,t){const n=e.map(i=>({methodName:"getConfirmedTransaction",args:this._buildArgsAtLeastConfirmed([i],t,"jsonParsed")}));return(await this._rpcBatchRequest(n)).map(i=>{const a=T(i,cn);if("error"in a)throw new F(a.error,"failed to get confirmed transactions");return a.result})}async getConfirmedSignaturesForAddress(e,t,n){let s={},o=await this.getFirstAvailableBlock();for(;!("until"in s)&&(t--,!(t<=0||t<o));)try{const c=await this.getConfirmedBlockSignatures(t,"finalized");c.signatures.length>0&&(s.until=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}let i=await this.getSlot("finalized");for(;!("before"in s)&&(n++,!(n>i));)try{const c=await this.getConfirmedBlockSignatures(n);c.signatures.length>0&&(s.before=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}return(await this.getConfirmedSignaturesForAddress2(e,s)).map(c=>c.signature)}async getConfirmedSignaturesForAddress2(e,t,n){const s=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),o=await this._rpcRequest("getConfirmedSignaturesForAddress2",s),i=T(o,Mu);if("error"in i)throw new F(i.error,"failed to get confirmed signatures for address");return i.result}async getSignaturesForAddress(e,t,n){const s=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),o=await this._rpcRequest("getSignaturesForAddress",s),i=T(o,Hu);if("error"in i)throw new F(i.error,"failed to get signatures for address");return i.result}async getAddressLookupTable(e,t){const{context:n,value:s}=await this.getAccountInfoAndContext(e,t);let o=null;return s!==null&&(o=new ds({key:e,state:ds.deserialize(s.data)})),{context:n,value:o}}async getNonceAndContext(e,t){const{context:n,value:s}=await this.getAccountInfoAndContext(e,t);let o=null;return s!==null&&(o=Ir.fromAccountData(s.data)),{context:n,value:o}}async getNonce(e,t){return await this.getNonceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+n)})}async requestAirdrop(e,t){const n=await this._rpcRequest("requestAirdrop",[e.toBase58(),t]),s=T(n,wl);if("error"in s)throw new F(s.error,`airdrop to ${e.toBase58()} failed`);return s.result}async _blockhashWithExpiryBlockHeight(e){if(!e){for(;this._pollingBlockhash;)await At(100);const n=Date.now()-this._blockhashInfo.lastFetch>=cu;if(this._blockhashInfo.latestBlockhash!==null&&!n)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const e=Date.now(),t=this._blockhashInfo.latestBlockhash,n=t?t.blockhash:null;for(let s=0;s<50;s++){const o=await this.getLatestBlockhash("finalized");if(n!==o.blockhash)return this._blockhashInfo={latestBlockhash:o,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},o;await At(Gc/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(e){const{commitment:t,config:n}=le(e),s=this._buildArgs([],t,"base64",n),o=await this._rpcRequest("getStakeMinimumDelegation",s),i=T(o,me(b()));if("error"in i)throw new F(i.error,"failed to get stake minimum delegation");return i.result}async simulateTransaction(e,t,n){if("message"in e){const d=e.serialize(),f=Z.Buffer.from(d).toString("base64");if(Array.isArray(t)||n!==void 0)throw new Error("Invalid arguments");const m=t||{};m.encoding="base64","commitment"in m||(m.commitment=this.commitment);const v=[f,m],h=await this._rpcRequest("simulateTransaction",v),k=T(h,fs);if("error"in k)throw new Error("failed to simulate transaction: "+k.error.message);return k.result}let s;if(e instanceof at){let g=e;s=new at,s.feePayer=g.feePayer,s.instructions=e.instructions,s.nonceInfo=g.nonceInfo,s.signatures=g.signatures}else s=at.populate(e),s._message=s._json=void 0;if(t!==void 0&&!Array.isArray(t))throw new Error("Invalid arguments");const o=t;if(s.nonceInfo&&o)s.sign(...o);else{let g=this._disableBlockhashCaching;for(;;){const d=await this._blockhashWithExpiryBlockHeight(g);if(s.lastValidBlockHeight=d.lastValidBlockHeight,s.recentBlockhash=d.blockhash,!o)break;if(s.sign(...o),!s.signature)throw new Error("!signature");const f=s.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(f)&&!this._blockhashInfo.transactionSignatures.includes(f)){this._blockhashInfo.simulatedSignatures.push(f);break}else g=!0}}const i=s._compile(),a=i.serialize(),u=s._serialize(a).toString("base64"),l={encoding:"base64",commitment:this.commitment};if(n){const g=(Array.isArray(n)?n:i.nonProgramIds()).map(d=>d.toBase58());l.accounts={encoding:"base64",addresses:g}}o&&(l.sigVerify=!0);const y=[u,l],_=await this._rpcRequest("simulateTransaction",y),p=T(_,fs);if("error"in p){let g;if("data"in p.error&&(g=p.error.data.logs,g&&Array.isArray(g))){const d=`
    `,f=d+g.join(d);console.error(p.error.message,f)}throw new us("failed to simulate transaction: "+p.error.message,g)}return p.result}async sendTransaction(e,t,n){if("version"in e){if(t&&Array.isArray(t))throw new Error("Invalid arguments");const i=e.serialize();return await this.sendRawTransaction(i,t)}if(t===void 0||!Array.isArray(t))throw new Error("Invalid arguments");const s=t;if(e.nonceInfo)e.sign(...s);else{let i=this._disableBlockhashCaching;for(;;){const a=await this._blockhashWithExpiryBlockHeight(i);if(e.lastValidBlockHeight=a.lastValidBlockHeight,e.recentBlockhash=a.blockhash,e.sign(...s),!e.signature)throw new Error("!signature");const c=e.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(c))i=!0;else{this._blockhashInfo.transactionSignatures.push(c);break}}}const o=e.serialize();return await this.sendRawTransaction(o,n)}async sendRawTransaction(e,t){const n=Lt(e).toString("base64");return await this.sendEncodedTransaction(n,t)}async sendEncodedTransaction(e,t){const n={encoding:"base64"},s=t&&t.skipPreflight,o=t&&t.preflightCommitment||this.commitment;t&&t.maxRetries!=null&&(n.maxRetries=t.maxRetries),t&&t.minContextSlot!=null&&(n.minContextSlot=t.minContextSlot),s&&(n.skipPreflight=s),o&&(n.preflightCommitment=o);const i=[e,n],a=await this._rpcRequest("sendTransaction",i),c=T(a,bl);if("error"in c){let u;throw"data"in c.error&&(u=c.error.data.logs),new us("failed to send transaction: "+c.error.message,u)}return c.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1,console.error("ws error:",e.message)}_wsOnClose(e){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),e===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([t,n])=>{this._setSubscription(t,{...n,state:"pending"})})}_setSubscription(e,t){var s;const n=(s=this._subscriptionsByHash[e])==null?void 0:s.state;if(this._subscriptionsByHash[e]=t,n!==t.state){const o=this._subscriptionStateChangeCallbacksByHash[e];o&&o.forEach(i=>{try{i(t.state)}catch{}})}}_onSubscriptionStateChange(e,t){var o;const n=this._subscriptionHashByClientSubscriptionId[e];if(n==null)return()=>{};const s=(o=this._subscriptionStateChangeCallbacksByHash)[n]||(o[n]=new Set);return s.add(t),()=>{s.delete(t),s.size===0&&delete this._subscriptionStateChangeCallbacksByHash[n]}}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(n){n instanceof Error&&console.log(`Error when closing socket connection: ${n.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}const e=this._rpcWebSocketGeneration,t=()=>e===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async n=>{const s=this._subscriptionsByHash[n];if(s!==void 0)switch(s.state){case"pending":case"unsubscribed":if(s.callbacks.size===0){delete this._subscriptionsByHash[n],s.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[s.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{const{args:o,method:i}=s;try{this._setSubscription(n,{...s,state:"subscribing"});const a=await this._rpcWebSocket.call(i,o);this._setSubscription(n,{...s,serverSubscriptionId:a,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[a]=s.callbacks,await this._updateSubscriptions()}catch(a){if(a instanceof Error&&console.error(`${i} error for argument`,o,a.message),!t())return;this._setSubscription(n,{...s,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":s.callbacks.size===0&&await(async()=>{const{serverSubscriptionId:o,unsubscribeMethod:i}=s;if(this._subscriptionsAutoDisposedByRpc.has(o))this._subscriptionsAutoDisposedByRpc.delete(o);else{this._setSubscription(n,{...s,state:"unsubscribing"}),this._setSubscription(n,{...s,state:"unsubscribing"});try{await this._rpcWebSocket.call(i,[o])}catch(a){if(a instanceof Error&&console.error(`${i} error:`,a.message),!t())return;this._setSubscription(n,{...s,state:"subscribed"}),await this._updateSubscriptions();return}}this._setSubscription(n,{...s,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(e,t){const n=this._subscriptionCallbacksByServerSubscriptionId[e];n!==void 0&&n.forEach(s=>{try{s(...t)}catch(o){console.error(o)}})}_wsOnAccountNotification(e){const{result:t,subscription:n}=T(e,$u);this._handleServerNotification(n,[t.value,t.context])}_makeSubscription(e,t){const n=this._nextClientSubscriptionId++,s=cs([e.method,t]),o=this._subscriptionsByHash[s];return o===void 0?this._subscriptionsByHash[s]={...e,args:t,callbacks:new Set([e.callback]),state:"pending"}:o.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[n]=s,this._subscriptionDisposeFunctionsByClientSubscriptionId[n]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n],delete this._subscriptionHashByClientSubscriptionId[n];const i=this._subscriptionsByHash[s];be(i!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${n}`),i.callbacks.delete(e.callback),await this._updateSubscriptions()},this._updateSubscriptions(),n}onAccountChange(e,t,n){const s=this._buildArgs([e.toBase58()],n||this._commitment||"finalized","base64");return this._makeSubscription({callback:t,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},s)}async removeAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"account change")}_wsOnProgramAccountNotification(e){const{result:t,subscription:n}=T(e,ju);this._handleServerNotification(n,[{accountId:t.value.pubkey,accountInfo:t.value.account},t.context])}onProgramAccountChange(e,t,n,s){const o=this._buildArgs([e.toBase58()],n||this._commitment||"finalized","base64",s?{filters:s}:void 0);return this._makeSubscription({callback:t,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},o)}async removeProgramAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"program account change")}onLogs(e,t,n){const s=this._buildArgs([typeof e=="object"?{mentions:[e.toString()]}:e],n||this._commitment||"finalized");return this._makeSubscription({callback:t,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},s)}async removeOnLogsListener(e){await this._unsubscribeClientSubscription(e,"logs")}_wsOnLogsNotification(e){const{result:t,subscription:n}=T(e,Sl);this._handleServerNotification(n,[t.value,t.context])}_wsOnSlotNotification(e){const{result:t,subscription:n}=T(e,Gu);this._handleServerNotification(n,[t])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(e){await this._unsubscribeClientSubscription(e,"slot change")}_wsOnSlotUpdatesNotification(e){const{result:t,subscription:n}=T(e,Zu);this._handleServerNotification(n,[t])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(e){await this._unsubscribeClientSubscription(e,"slot update")}async _unsubscribeClientSubscription(e,t){const n=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];n?await n():console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)}_buildArgs(e,t,n,s){const o=t||this._commitment;if(o||n||s){let i={};n&&(i.encoding=n),o&&(i.commitment=o),s&&(i=Object.assign(i,s)),e.push(i)}return e}_buildArgsAtLeastConfirmed(e,t,n,s){const o=t||this._commitment;if(o&&!["confirmed","finalized"].includes(o))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,t,n,s)}_wsOnSignatureNotification(e){const{result:t,subscription:n}=T(e,Yu);t.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(n),this._handleServerNotification(n,t.value==="receivedSignature"?[{type:"received"},t.context]:[{type:"status",result:t.value},t.context])}onSignature(e,t,n){const s=this._buildArgs([e],n||this._commitment||"finalized"),o=this._makeSubscription({callback:(i,a)=>{if(i.type==="status"){t(i.result,a);try{this.removeSignatureListener(o)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},s);return o}onSignatureWithOptions(e,t,n){const{commitment:s,...o}={...n,commitment:n&&n.commitment||this._commitment||"finalized"},i=this._buildArgs([e],s,void 0,o),a=this._makeSubscription({callback:(c,u)=>{t(c,u);try{this.removeSignatureListener(a)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},i);return a}async removeSignatureListener(e){await this._unsubscribeClientSubscription(e,"signature result")}_wsOnRootNotification(e){const{result:t,subscription:n}=T(e,Xu);this._handleServerNotification(n,[t])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(e){await this._unsubscribeClientSubscription(e,"root change")}}class Gt{constructor(e){this._keypair=void 0,this._keypair=e??ss()}static generate(){return new Gt(ss())}static fromSecretKey(e,t){if(e.byteLength!==64)throw new Error("bad secret key size");const n=e.slice(32,64);if(!t||!t.skipValidation){const s=e.slice(0,32),o=Xn(s);for(let i=0;i<32;i++)if(n[i]!==o[i])throw new Error("provided secretKey is invalid")}return new Gt({publicKey:n,secretKey:e})}static fromSeed(e){const t=Xn(e),n=new Uint8Array(64);return n.set(e),n.set(t,32),new Gt({publicKey:t,secretKey:n})}get publicKey(){return new M(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}Object.freeze({CreateLookupTable:{index:0,layout:q([K("instruction"),Nt("recentSlot"),se("bumpSeed")])},FreezeLookupTable:{index:1,layout:q([K("instruction")])},ExtendLookupTable:{index:2,layout:q([K("instruction"),Nt(),Ce(J(),bt(K(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:q([K("instruction")])},CloseLookupTable:{index:4,layout:q([K("instruction")])}});new M("AddressLookupTab1e1111111111111111111111111");Object.freeze({RequestUnits:{index:0,layout:q([se("instruction"),K("units"),K("additionalFee")])},RequestHeapFrame:{index:1,layout:q([se("instruction"),K("bytes")])},SetComputeUnitLimit:{index:2,layout:q([se("instruction"),K("units")])},SetComputeUnitPrice:{index:3,layout:q([se("instruction"),Nt("microLamports")])}});new M("ComputeBudget111111111111111111111111111111");q([se("numSignatures"),se("padding"),Fe("signatureOffset"),Fe("signatureInstructionIndex"),Fe("publicKeyOffset"),Fe("publicKeyInstructionIndex"),Fe("messageDataOffset"),Fe("messageDataSize"),Fe("messageInstructionIndex")]);new M("Ed25519SigVerify111111111111111111111111111");Ar.utils.isValidPrivateKey;Ar.getPublicKey;q([se("numSignatures"),Fe("signatureOffset"),se("signatureInstructionIndex"),Fe("ethAddressOffset"),se("ethAddressInstructionIndex"),Fe("messageDataOffset"),Fe("messageDataSize"),se("messageInstructionIndex"),ge(20,"ethAddress"),ge(64,"signature"),se("recoveryId")]);new M("KeccakSecp256k11111111111111111111111111111");new M("StakeConfig11111111111111111111111111111111");class gs{constructor(e,t,n){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=n}}gs.default=new gs(0,0,M.default);Object.freeze({Initialize:{index:0,layout:q([K("instruction"),zc(),Kc()])},Authorize:{index:1,layout:q([K("instruction"),J("newAuthorized"),K("stakeAuthorizationType")])},Delegate:{index:2,layout:q([K("instruction")])},Split:{index:3,layout:q([K("instruction"),Ne("lamports")])},Withdraw:{index:4,layout:q([K("instruction"),Ne("lamports")])},Deactivate:{index:5,layout:q([K("instruction")])},Merge:{index:7,layout:q([K("instruction")])},AuthorizeWithSeed:{index:8,layout:q([K("instruction"),J("newAuthorized"),K("stakeAuthorizationType"),It("authoritySeed"),J("authorityOwner")])}});new M("Stake11111111111111111111111111111111111111");Object.freeze({InitializeAccount:{index:0,layout:q([K("instruction"),Mc()])},Authorize:{index:1,layout:q([K("instruction"),J("newAuthorized"),K("voteAuthorizationType")])},Withdraw:{index:3,layout:q([K("instruction"),Ne("lamports")])},AuthorizeWithSeed:{index:10,layout:q([K("instruction"),Hc()])}});new M("Vote111111111111111111111111111111111111111");new M("Va1idator1nfo111111111111111111111111111111");I({name:R(),website:H(R()),details:H(R()),keybaseUsername:H(R())});new M("Vote111111111111111111111111111111111111111");q([J("nodePubkey"),J("authorizedWithdrawer"),se("commission"),ke(),Ce(q([ke("slot"),K("confirmationCount")]),bt(K(),-8),"votes"),se("rootSlotValid"),ke("rootSlot"),ke(),Ce(q([ke("epoch"),J("authorizedVoter")]),bt(K(),-8),"authorizedVoters"),q([Ce(q([J("authorizedPubkey"),ke("epochOfLastAuthorizedSwitch"),ke("targetEpoch")]),32,"buf"),ke("idx"),se("isEmpty")],"priorVoters"),ke(),Ce(q([ke("epoch"),ke("credits"),ke("prevCredits")]),bt(K(),-8),"epochCredits"),q([ke("slot"),ke("timestamp")],"lastTimestamp")]);var un=rr.Buffer;function El(r){if(r.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),t=0;t<e.length;t++)e[t]=255;for(var n=0;n<r.length;n++){var s=r.charAt(n),o=s.charCodeAt(0);if(e[o]!==255)throw new TypeError(s+" is ambiguous");e[o]=n}var i=r.length,a=r.charAt(0),c=Math.log(i)/Math.log(256),u=Math.log(256)/Math.log(i);function l(p){if((Array.isArray(p)||p instanceof Uint8Array)&&(p=un.from(p)),!un.isBuffer(p))throw new TypeError("Expected Buffer");if(p.length===0)return"";for(var g=0,d=0,f=0,m=p.length;f!==m&&p[f]===0;)f++,g++;for(var v=(m-f)*u+1>>>0,h=new Uint8Array(v);f!==m;){for(var k=p[f],w=0,E=v-1;(k!==0||w<d)&&E!==-1;E--,w++)k+=256*h[E]>>>0,h[E]=k%i>>>0,k=k/i>>>0;if(k!==0)throw new Error("Non-zero carry");d=w,f++}for(var x=v-d;x!==v&&h[x]===0;)x++;for(var A=a.repeat(g);x<v;++x)A+=r.charAt(h[x]);return A}function y(p){if(typeof p!="string")throw new TypeError("Expected String");if(p.length===0)return un.alloc(0);for(var g=0,d=0,f=0;p[g]===a;)d++,g++;for(var m=(p.length-g)*c+1>>>0,v=new Uint8Array(m);p[g];){var h=e[p.charCodeAt(g)];if(h===255)return;for(var k=0,w=m-1;(h!==0||k<f)&&w!==-1;w--,k++)h+=i*v[w]>>>0,v[w]=h%256>>>0,h=h/256>>>0;if(h!==0)throw new Error("Non-zero carry");f=k,g++}for(var E=m-f;E!==m&&v[E]===0;)E++;var x=un.allocUnsafe(d+(m-E));x.fill(0,0,d);for(var A=d;E!==m;)x[A++]=v[E++];return x}function _(p){var g=y(p);if(g)return g;throw new Error("Non-base"+i+" character")}return{encode:l,decodeUnsafe:y,decode:_}}var _l=El,kl=_l,Bl="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",Al=kl(Bl);const De=Yt(Al);function Il(r){return(e,t,n,s)=>e.method==="solana_chainId"?(t.result=r,s()):n()}function Rl(r){return(e,t,n,s)=>e.method==="solana_provider_config"?(t.result=r,s()):n()}function Mo(r){const{chainId:e}=r;return Xt([Il(e),Rl(r)])}function Cl(r){const{rpcTarget:e}=r,t=li({rpcTarget:e});return{networkMiddleware:Xt([Mo(r),t]),fetchMiddleware:t}}function Tl(r){let{getAccounts:e}=r;return xn(async(t,n,s)=>{const{method:o}=t;if(o!=="getAccounts")return s();if(!e)throw new Error("WalletMiddleware - opts.getAccounts not provided");const i=await e(t);n.result=i})}function Ol(r){let{requestAccounts:e}=r;return xn(async(t,n,s)=>{const{method:o}=t;if(o!=="requestAccounts")return s();if(!e)throw new Error("WalletMiddleware - opts.requestAccounts not provided");const i=await e(t);n.result=i})}function et(r,e){return xn(async(t,n,s)=>{const{method:o}=t;if(o!==r)return s();if(!e)throw new Error("WalletMiddleware - ".concat(r," not provided"));const i=await e(t);n.result=i})}function Pr(r){const{getAccounts:e,requestAccounts:t,signTransaction:n,signAndSendTransaction:s,signAllTransactions:o,signMessage:i,getPrivateKey:a,getSecretKey:c}=r;return Xt([Ol({requestAccounts:t}),Tl({getAccounts:e}),et("signTransaction",n),et("signAndSendTransaction",s),et("signAllTransactions",o),et("signMessage",i),et("solanaPrivateKey",a),et("solanaSecretKey",c)])}function Pl(r){let{addNewChainConfig:e,switchSolanaChain:t}=r;return Xt([et("addSolanaChain",e),et("switchSolanaChain",t)])}function Ll(r){let{updatePrivatekey:e}=r;return Xt([et("updateAccount",e)])}function ys(r,e){var t=Object.keys(r);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(r);e&&(n=n.filter(function(s){return Object.getOwnPropertyDescriptor(r,s).enumerable})),t.push.apply(t,n)}return t}function ms(r){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?arguments[e]:{};e%2?ys(Object(t),!0).forEach(function(n){Ut(r,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(r,Object.getOwnPropertyDescriptors(t)):ys(Object(t)).forEach(function(n){Object.defineProperty(r,n,Object.getOwnPropertyDescriptor(t,n))})}return r}class Pn extends ir{constructor(e){let{config:t,state:n}=e;super({config:{chainConfig:ms(ms({},t.chainConfig),{},{chainNamespace:fn.SOLANA})},state:n})}async switchChain(e){return Promise.resolve()}async setupProvider(e){const t=new or,n=this.getProviderHandlers(e),s=Pr(n);t.push(s);const o=Mo(this.config.chainConfig);t.push(o);const i=this.getInjectedProviderProxy(e);i&&t.push(i);const a=ar(t);this.updateProviderEngineProxy(a),await this.lookupNetwork()}async lookupNetwork(){const{chainConfig:e}=this.config;return this.update({chainId:e.chainId}),e.chainId||""}getInjectedProviderProxy(e){}}const Lr=r=>({requestAccounts:async()=>r.publicKey?[De.encode(r.publicKey.toBytes())]:[],getAccounts:async()=>r.publicKey?[De.encode(r.publicKey.toBytes())]:[],getPrivateKey:async()=>{throw ee.ethErrors.rpc.methodNotSupported()},getSecretKey:async()=>{throw ee.ethErrors.rpc.methodNotSupported()},signTransaction:async t=>await r.signTransaction(t.params.message),signMessage:async t=>(await r.signMessage(t.params.message,t.params.display)).signature,signAllTransactions:async t=>{var n,s;if(!((n=t.params)!==null&&n!==void 0&&n.message)||!((s=t.params)!==null&&s!==void 0&&s.message.length))throw ee.ethErrors.rpc.invalidParams("message");return await r.signAllTransactions(t.params.message)},signAndSendTransaction:async t=>({signature:(await r.signAndSendTransaction(t.params.message)).signature})});function ws(r,e){var t=Object.keys(r);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(r);e&&(n=n.filter(function(s){return Object.getOwnPropertyDescriptor(r,s).enumerable})),t.push.apply(t,n)}return t}function Nl(r){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?arguments[e]:{};e%2?ws(Object(t),!0).forEach(function(n){Ut(r,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(r,Object.getOwnPropertyDescriptors(t)):ws(Object(t)).forEach(function(n){Object.defineProperty(r,n,Object.getOwnPropertyDescriptor(t,n))})}return r}function Ho(r){return xn(async(e,t,n)=>{const s=await r.request(Nl({},e));t.result=s})}class Ul extends Pn{getProviderHandlers(e){return Lr(e)}getInjectedProviderProxy(e){return Ho(e)}}const ql=(r,e)=>({requestAccounts:async()=>{const{data:n}=await r.connect();return[n.publicKey]},getAccounts:async()=>{const{data:n}=await r.connect();return[n.publicKey]},getPrivateKey:async()=>{throw ee.ethErrors.rpc.methodNotSupported()},getSecretKey:async()=>{throw ee.ethErrors.rpc.methodNotSupported()},signTransaction:async n=>{const s=n.params.message;if(!s)throw ee.ethErrors.rpc.invalidRequest({message:"Invalid transaction message"});const{data:o}=await r.signTransaction(De.encode(s.serializeMessage()));if(!o.publicKey||!o.signature)throw new Error("Invalid signature from slope wallet");const i=new M(o.publicKey),a=De.decode(o.signature);return s.addSignature(i,a),s},signMessage:async n=>{const s=await r.signMessage(n.params.message);return De.decode(s.data.signature)},signAndSendTransaction:async n=>{const s=e();if(!s)throw ee.ethErrors.provider.custom({message:"Provider is not initialized",code:4902});const o=n.params.message;if(!o)throw ee.ethErrors.rpc.invalidRequest({message:"Invalid transaction message"});const{data:i}=await r.signTransaction(De.encode(o.serializeMessage()));if(!i.publicKey||!i.signature)throw new Error("Invalid signature from slope wallet");const a=new M(i.publicKey),c=De.decode(i.signature);o.addSignature(a,c);const u=await s.request({method:"solana_provider_config",params:[]});return{signature:await new Or(u.rpcTarget).sendRawTransaction(o.serialize())}},signAllTransactions:async n=>{var s,o,i;if(!((s=n.params)!==null&&s!==void 0&&s.message)||!((o=n.params)!==null&&o!==void 0&&o.message.length))throw ee.ethErrors.rpc.invalidParams("message");const a=n.params.message,{length:c}=a,u=[];for(let p=0;p<c;p++)u.push(De.encode(n.params.message[p].serializeMessage()));const{msg:l,data:y}=await r.signAllTransactions(u);if(!y.publicKey||((i=y.signatures)===null||i===void 0?void 0:i.length)!==c)throw new Error(l);const _=new M(y.publicKey);for(let p=0;p<c;p++){const g=De.decode(y.signatures[p]);a[p].addSignature(_,g)}return a}});class Fl extends Pn{getProviderHandlers(e){return ql(e,this.getProviderEngineProxy.bind(this))}}const zl=(r,e)=>{const t=Lr(r);return t.signAndSendTransaction=async n=>{const s=e();if(!s)throw ee.ethErrors.provider.custom({message:"Provider is not initialized",code:4902});const o=await r.signTransaction(n.params.message),i=await s.request({method:"solana_provider_config",params:[]});return{signature:await new Or(i.rpcTarget).sendRawTransaction(o.serialize())}},t};class Kl extends Pn{getProviderHandlers(e){return zl(e,this.getProviderEngineProxy.bind(this))}}const Ml=(r,e)=>{const t=Lr(r);return t.signMessage=async n=>{const{signature:s}=await r.sign(n.params.message,"utf8");return s},t.signAndSendTransaction=async n=>{const s=e();if(!s)throw ee.ethErrors.provider.custom({message:"Provider is not initialized",code:4902});const o=await r.signTransaction(n.params.message),i=await s.request({method:"solana_provider_config",params:[]});return{signature:await new Or(i.rpcTarget).sendRawTransaction(o.serialize())}},t};class Hl extends Pn{getProviderHandlers(e){return Ml(e,this.getProviderEngineProxy.bind(this))}}const $l=r=>({requestAccounts:async()=>await r.request({method:"solana_requestAccounts",params:{}}),getAccounts:async()=>await r.request({method:"solana_requestAccounts",params:{}}),getPrivateKey:async()=>{throw ee.ethErrors.rpc.methodNotSupported()},getSecretKey:async()=>{throw ee.ethErrors.rpc.methodNotSupported()},signMessage:async t=>{var n;if(!((n=t.params)!==null&&n!==void 0&&n.message))throw ee.ethErrors.rpc.invalidParams("message");return await r.signMessage(t.params.message)},signTransaction:async t=>{var n;if(!((n=t.params)!==null&&n!==void 0&&n.message))throw ee.ethErrors.rpc.invalidParams("message");const s=t.params.message;return await r.signTransaction(s)},signAndSendTransaction:async t=>{var n;if(!((n=t.params)!==null&&n!==void 0&&n.message))throw ee.ethErrors.rpc.invalidParams("message");const s=t.params.message;return{signature:await r.sendTransaction(s)}},signAllTransactions:async t=>{var n,s;if(!((n=t.params)!==null&&n!==void 0&&n.message)||!((s=t.params)!==null&&s!==void 0&&s.message.length))throw ee.ethErrors.rpc.invalidParams("message");const o=t.params.message;return await r.signAllTransactions(o)}});function bs(r,e){var t=Object.keys(r);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(r);e&&(n=n.filter(function(s){return Object.getOwnPropertyDescriptor(r,s).enumerable})),t.push.apply(t,n)}return t}function ln(r){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?arguments[e]:{};e%2?bs(Object(t),!0).forEach(function(n){Ut(r,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(r,Object.getOwnPropertyDescriptors(t)):bs(Object(t)).forEach(function(n){Object.defineProperty(r,n,Object.getOwnPropertyDescriptor(t,n))})}return r}class Dl extends ir{constructor(e){let{config:t,state:n}=e;super({config:{chainConfig:ln(ln({},t.chainConfig),{},{chainNamespace:fn.SOLANA})},state:n})}async switchChain(e){return Promise.resolve()}async setupProvider(e){this.handleInjectedProviderUpdate(e),await this.setupEngine(e)}async lookupNetwork(){if(!this.provider)throw ee.ethErrors.provider.custom({message:"Torus solana provider is not initialized",code:4902});const{chainId:e}=this.config.chainConfig,t=await this.provider.request({method:"solana_chainId"}),n=Dr(t.toString())?t:"0x".concat(parseInt(t,10).toString(16));if(e!==n)throw sr.rpcConnectionError("Invalid network, net_version is: ".concat(n,", expected: ").concat(e));return this.update({chainId:n}),this.provider.emit("connect",{chainId:this.state.chainId}),this.provider.emit("chainChanged",this.state.chainId),this.state.chainId}async setupEngine(e){const t=$l(e),n=Pr(t),s=Ho(e),o=new or;o.push(n),o.push(s);const i=ar(o);this.updateProviderEngineProxy(i),await this.lookupNetwork()}async handleInjectedProviderUpdate(e){e.on("accountsChanged",async t=>{this.provider.emit("accountsChanged",t)}),e.on("chainChanged",async t=>{const n=Dr(t)?t:"0x".concat(parseInt(t,10).toString(16));this.configure({chainConfig:ln(ln({},this.config.chainConfig),{},{chainId:n})}),await this.setupProvider(e)})}}async function jl(r){let{privKey:e,getProviderEngineProxy:t}=r;const n=()=>Gt.fromSecretKey(Buffer.from(e,"hex"));if(typeof e!="string")throw sr.invalidParams("privKey must be a string");const s=n();return{requestAccounts:async()=>[s.publicKey.toBase58()],getAccounts:async()=>[s.publicKey.toBase58()],getPrivateKey:async()=>e,getSecretKey:async()=>De.encode(s.secretKey),signTransaction:async i=>{var a;if(!((a=i.params)!==null&&a!==void 0&&a.message))throw ee.ethErrors.rpc.invalidParams("message");const c=i.params.message;return c.partialSign(s),c},signMessage:async i=>{var a;if(!((a=i.params)!==null&&a!==void 0&&a.message))throw ee.ethErrors.rpc.invalidParams("message");return di.sign.detached(i.params.message,s.secretKey)},signAndSendTransaction:async i=>{var a;if(!((a=i.params)!==null&&a!==void 0&&a.message))throw ee.ethErrors.rpc.invalidParams("message");const c=t();if(!c)throw ee.ethErrors.provider.custom({message:"Provider is not initialized",code:4902});const u=i.params.message;return u.sign(s),{signature:await c.request({method:"sendTransaction",params:[De.encode(u.serialize())]})}},signAllTransactions:async i=>{var a,c,u;if(!((a=i.params)!==null&&a!==void 0&&a.message)||!((c=i.params)!==null&&c!==void 0&&c.message.length))throw ee.ethErrors.rpc.invalidParams("message");const l=(u=i.params)===null||u===void 0?void 0:u.message;for(const y of l||[])y.partialSign(s);return l}}}function vs(r,e){var t=Object.keys(r);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(r);e&&(n=n.filter(function(s){return Object.getOwnPropertyDescriptor(r,s).enumerable})),t.push.apply(t,n)}return t}function Ss(r){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?arguments[e]:{};e%2?vs(Object(t),!0).forEach(function(n){Ut(r,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(r,Object.getOwnPropertyDescriptors(t)):vs(Object(t)).forEach(function(n){Object.defineProperty(r,n,Object.getOwnPropertyDescriptor(t,n))})}return r}class nr extends ir{constructor(e){let{config:t,state:n}=e;super({config:{chainConfig:Ss(Ss({},t.chainConfig),{},{chainNamespace:fn.SOLANA})},state:n})}async enable(){if(!this.state.privateKey)throw ee.ethErrors.provider.custom({message:"Private key is not found in state, plz pass it in constructor state param",code:4902});return await this.setupProvider(this.state.privateKey),this._providerEngineProxy.request({method:"eth_accounts"})}async setupProvider(e){const t=await jl({privKey:e,getProviderEngineProxy:this.getProviderEngineProxy.bind(this)}),n=Pr(t),s=new or,{networkMiddleware:o}=Cl(this.config.chainConfig);s.push(this.getChainSwitchMiddleware()),s.push(this.getAccountMiddleware()),s.push(n),s.push(o);const i=ar(s);this.updateProviderEngineProxy(i),await this.lookupNetwork()}async updateAccount(e){if(!this._providerEngineProxy)throw ee.ethErrors.provider.custom({message:"Provider is not initialized",code:4902});await this._providerEngineProxy.request({method:"solanaPrivateKey"})!==e.privateKey&&(await this.setupProvider(e.privateKey),this._providerEngineProxy.emit("accountsChanged",{accounts:await this._providerEngineProxy.request({method:"requestAccounts"})}))}async switchChain(e){if(!this._providerEngineProxy)throw ee.ethErrors.provider.custom({message:"Provider is not initialized",code:4902});const t=this.getChainConfig(e.chainId);this.update({chainId:"loading"}),this.configure({chainConfig:t});const n=await this._providerEngineProxy.request({method:"solanaPrivateKey"});await this.setupProvider(n)}async lookupNetwork(){if(!this._providerEngineProxy)throw ee.ethErrors.provider.custom({message:"Provider is not initialized",code:4902});const e=await this._providerEngineProxy.request({method:"getHealth",params:[]}),{chainConfig:t}=this.config;if(e!=="ok")throw sr.rpcConnectionError("Failed to lookup network for following rpc target: ".concat(t.rpcTarget));return this.update({chainId:t.chainId}),this.state.chainId!==t.chainId&&(this.provider.emit("chainChanged",this.state.chainId),this.provider.emit("connect",{chainId:this.state.chainId})),this.state.chainId}getChainSwitchMiddleware(){return Pl({addNewChainConfig:async n=>{if(!n.params)throw ee.ethErrors.rpc.invalidParams("Missing request params");const{chainId:s,chainName:o,rpcUrls:i,blockExplorerUrls:a,nativeCurrency:c}=n.params;if(!s)throw ee.ethErrors.rpc.invalidParams("Missing chainId in chainParams");if(!i||i.length===0)throw ee.ethErrors.rpc.invalidParams("Missing rpcUrls in chainParams");if(!c)throw ee.ethErrors.rpc.invalidParams("Missing nativeCurrency in chainParams");this.addChain({chainNamespace:fn.SOLANA,chainId:s,ticker:(c==null?void 0:c.symbol)||"SOL",tickerName:(c==null?void 0:c.name)||"Solana",displayName:o,rpcTarget:i[0],blockExplorer:(a==null?void 0:a[0])||""})},switchSolanaChain:async n=>{if(!n.params)throw ee.ethErrors.rpc.invalidParams("Missing request params");if(!n.params.chainId)throw ee.ethErrors.rpc.invalidParams("Missing chainId");await this.switchChain(n.params)}})}getAccountMiddleware(){return Ll({updatePrivatekey:async t=>{if(!t.params)throw ee.ethErrors.rpc.invalidParams("Missing request params");if(!t.params.privateKey)throw ee.ethErrors.rpc.invalidParams("Missing privateKey");const{privateKey:n}=t.params;await this.updateAccount({privateKey:n})}})}}Ut(nr,"getProviderInstance",async r=>{const e=new nr({config:{chainConfig:r.chainConfig}});return await e.setupProvider(r.privKey),e});class Wl{constructor(e){Ut(this,"provider",void 0),this.provider=e}async requestAccounts(){return await this.provider.request({method:"requestAccounts",params:{}})}async signAndSendTransaction(e){const{signature:t}=await this.provider.request({method:"signAndSendTransaction",params:{message:e}});return{signature:t}}async signTransaction(e){return await this.provider.request({method:"signTransaction",params:{message:e}})}async signAllTransactions(e){return await this.provider.request({method:"signAllTransactions",params:{message:e}})}async signMessage(e){return await this.provider.request({method:"signMessage",params:{message:e}})}async request(e){return await this.provider.request(e)}}const Ql=Object.freeze(Object.defineProperty({__proto__:null,PhantomInjectedProvider:Ul,SlopeInjectedProxyProvider:Fl,SolanaPrivateKeyProvider:nr,SolanaWallet:Wl,SolflareInjectedProvider:Kl,SolletInjectedProvider:Hl,TorusInjectedProvider:Dl},Symbol.toStringTag,{value:"Module"}));export{M as P,Dl as T,Ul as a,Ql as s};
